<!DOCTYPE html>
<html lang="zh-Hant" data-app>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>é›¢ç·šåŒ¯å·®è¨ˆç®—å™¨ v3ï½œæ°´å–® & é€²å‡ºå£å ±å–®</title>
  <script src="https://unpkg.com/localforage@1.10.0/dist/localforage.min.js"></script>
  <style>
    /* ===== Theme System (Light / Dark) ===== */
    :root{
      /* light theme defaults */
      --bg:#f8fafc;          /* slate-50 */
      --panel:#ffffff;       /* white */
      --panel-2:#f1f5f9;     /* slate-100 */
      --muted:#475569;       /* slate-600 */
      --text:#0f172a;        /* slate-900 */
      --accent:#0056b3;      /* Deep Midnight Blue (formerly #0284c7) */
      --accent-2:#007bff;    /* Vibrant Azure (formerly #06b6d4) */
      --ok:#10b981;          /* emerald-500 */
      --bad:#ef4444;         /* red-500 */
      --warn:#d97706;        /* amber-600 */
      --card:#ffffff;
      --border:#e2e8f0;      /* slate-200 */
      --input-bg:#ffffff;
      --input-text:#0f172a;
      --table-stripe:#f8fafc;
      --shadow:0 10px 30px rgba(2,6,23,.06);
      --shadow-hover:0 12px 35px rgba(2,6,23,.12);
      --shadow-focus:0 0 0 3px color-mix(in oklab, var(--accent) 25%, transparent), inset 0 1px 3px rgba(0,0,0,.1);
      --code:#0f172a;
      --highlight-bg: color-mix(in oklab, var(--accent) 10%, transparent);
      --highlight-border: var(--accent);
    }

    [data-theme="dark"]{
      --bg:#0b1220;          /* deep blue */
      --panel:#0f172a;       /* slate-900 */
      --panel-2:#0a1220;
      --muted:#94a3b8;       /* slate-400 */
      --text:#e2e8f0;        /* slate-200 */
      --accent:#3d8bdc;      /* Lighter Deep Midnight Blue for dark theme (formerly #22d3ee) */
      --accent-2:#5cacef;    /* Lighter Vibrant Azure for dark theme (formerly #38bdf8) */
      --ok:#34d399;          /* green-400 */
      --bad:#fb7185;         /* rose-400 */
      --warn:#f59e0b;        /* amber-500 */
      --card:#0f172a;
      --border:#1f2a44;
      --input-bg:#0a1220;
      --input-text:#e2e8f0;
      --table-stripe:#0b1628;
      --shadow:0 10px 30px rgba(0,0,0,.25);
      --shadow-hover:0 12px 35px rgba(0,0,0,.35);
      --shadow-focus:0 0 0 3px color-mix(in oklab, var(--accent) 25%, transparent), inset 0 1px 3px rgba(0,0,0,.25);
      --code:#e2e8f0;
      --highlight-bg: color-mix(in oklab, var(--accent) 10%, transparent);
      --highlight-border: var(--accent);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 600px at 10% -10%,var(--panel-2) 0%,transparent 60%),linear-gradient(0deg,var(--bg),var(--bg));color:var(--text);font:14px/1.7 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji"}
    h1,h2{margin:.2rem 0 1rem;line-height:1.3}
    h1{font-size:1.6rem} /* Increased font size */
    h2{font-size:1.2rem;color:var(--text)} /* Increased font size */
    .wrap{max-width:1200px;margin:0 auto;padding:30px 20px;} /* Increased padding */

    .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px} /* Increased margin */
    .theme-toggle{display:flex;gap:8px;align-items:center}
    .theme-btn{border:1px solid var(--border);background:var(--panel);color:var(--text);border-radius:999px;padding:6px 10px;cursor:pointer;box-shadow:var(--shadow);transition:.18s}
    .theme-btn:hover{transform:translateY(-2px);box-shadow:var(--shadow-hover)}

    .tabs{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:20px;align-items:center} /* Increased gap and margin */
    .tab{
      border:1px solid var(--border);background:var(--panel);color:var(--text);border-radius:999px;padding:8px 16px;cursor:pointer;transition:.18s;box-shadow:var(--shadow);
    }
    .tab:hover{transform:translateY(-2px);box-shadow:var(--shadow-hover)}
    .tab.active{background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#fff;font-weight:700;border-color:transparent;box-shadow:var(--shadow-hover)}

    .grid{display:grid;gap:16px} /* Increased gap */
    .grid.cols-2{grid-template-columns:1fr 1fr}
    .grid.cols-3{grid-template-columns:repeat(3,1fr)}
    .split{display:grid;grid-template-columns: 1.3fr .7fr;gap:16px} /* Increased gap */
    @media (max-width: 900px){.grid.cols-2,.grid.cols-3,.split{grid-template-columns:1fr}}

    .row{display:flex;gap:12px;align-items:flex-end} /* Increased gap */
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:20px;box-shadow:var(--shadow);margin-bottom:16px;} /* Increased padding, added margin */
    .panel-content-spacing { margin-bottom: 20px; }
    label{font-size:.85rem;color:var(--muted);margin-bottom:4px;display:block;}

    input,select,textarea{width:100%;background:var(--input-bg);color:var(--input-text);border:1px solid var(--border);border-radius:10px;padding:10px 12px;outline:none;transition:.18s} /* Increased padding */
    input:focus,select:focus,textarea:focus{border-color:var(--accent);box-shadow:var(--shadow-focus);}
    textarea{min-height:100px}

    table{width:100%;border-collapse:collapse;background:var(--panel);border-radius:12px;overflow:hidden;}
    thead{position:sticky;top:0;background:var(--panel)}
    th,td{border-bottom:1px solid var(--border);padding:12px 10px;text-align:left;color:var(--text)} /* Increased padding */
    tbody tr:nth-child(odd){background:var(--table-stripe)}
    tbody tr:hover{background:color-mix(in oklab, var(--accent) 5%, transparent);cursor:pointer;} /* Added hover effect */
    tbody tr.is-selected{background:var(--highlight-bg);border-left:4px solid var(--highlight-border);} /* Selected row style */
    tbody tr.is-selected td{font-weight:600;}

    .base-btn{
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      border-radius:10px;
      padding:8px 12px;
      cursor:pointer;
      box-shadow:var(--shadow);
      transition:.18s ease;
      font-weight:500;
    }
    .base-btn:hover{transform:translateY(-2px);box-shadow:var(--shadow-hover);}
    .btn{
      composes: base-btn; /* Inherits base-btn styles */
    }
    .btn.primary{background:linear-gradient(90deg,var(--accent),var(--accent-2));border:none;color:#fff;font-weight:700;}
    .btn.primary:hover{box-shadow:var(--shadow-hover);background:linear-gradient(90deg,color-mix(in oklab, var(--accent) 80%, black),color-mix(in oklab, var(--accent-2) 80%, black));}
    .btn.ghost{background:transparent;border:none;box-shadow:none;}
    .btn.ghost:hover{background:color-mix(in oklab, var(--muted) 10%, transparent);box-shadow:none;}
    .btn.warn{background:linear-gradient(90deg,#f59e0b,#f97316);border:none;color:#111;font-weight:700;}
    .btn.warn:hover{box-shadow:var(--shadow-hover);background:linear-gradient(90deg,color-mix(in oklab, #f59e0b 80%, black),color-mix(in oklab, #f97316 80%, black));}
    .btn.danger{background:linear-gradient(90deg,#fb7185,#ef4444);border:none;color:#111;font-weight:700;}
    .btn.danger:hover{box-shadow:var(--shadow-hover);background:linear-gradient(90deg,color-mix(in oklab, #fb7185 80%, black),color-mix(in oklab, #ef4444 80%, black));}


    .pill{padding:4px 10px;border-radius:999px;border:1px solid var(--border);font-size:.75rem;opacity:.9} /* Increased padding */
    .gain{background:color-mix(in oklab, var(--ok) 18%, transparent);color:var(--ok)}
    .loss{background:color-mix(in oklab, var(--bad) 18%, transparent);color:var(--bad)}
    .muted{color:var(--muted)}
    .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;color:var(--code)}
    .right{display:flex;justify-content:flex-end;gap:8px}
    .hint{font-size:.8rem;color:var(--muted);line-height:1.4;margin-top:8px;}
    .sticky{position:sticky;top:20px;} /* Increased top */
    .footer{margin-top:24px;color:var(--muted);font-size:.8rem} /* Increased margin */
    .small{font-size:.85rem}
    .allocation-detail-row td {
      padding-top: 0;
      padding-bottom: 0;
    }
    .allocation-detail-content {
      padding: 12px; /* Increased padding */
      background: var(--panel-2);
      border-radius: 8px;
      margin: 12px 0; /* Increased margin */
    }
    .allocation-detail-content table {
      width: calc(100% - 16px);
      margin: 0 8px;
    }
    .allocation-detail-content th,
    .allocation-detail-content td {
      padding: 6px 8px; /* Increased padding */
      font-size: 0.8rem;
    }
    .allocation-detail-content tbody tr:nth-child(odd) {
      background: transparent; /* No stripe for nested table */
    }

    /* Panel transition animation */
    .panel-container {
      position: relative;
      min-height: 200px; /* Prevent layout shift during transitions */
    }
    .panel-wrapper {
      position: absolute;
      width: 100%;
      top: 0;
      left: 0;
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.3s ease-out, transform 0.3s ease-out;
    }
    .panel-wrapper.is-active {
      opacity: 1;
      transform: translateY(0);
      position: relative;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1 id="appTitle">é›¢ç·šåŒ¯å·®è¨ˆç®—å™¨ v3ï½œæ°´å–® & é€²å‡ºå£å ±å–®</h1>
      <div class="theme-toggle">
        <span class="muted">ä¸»é¡Œ</span>
        <button id="theme-btn" class="theme-btn" title="åˆ‡æ›äº®/æš—">ğŸŒ— åˆ‡æ›</button>
      </div>
    </div>

    <!-- Quick bar: Global Customer/Vendor + Allocation actions -->
    <div class="row card panel-content-spacing">
      <div style="flex:1;">
        <label for="globalVendor">å®¢æˆ¶ï¼ˆç¯©é¸å» å•†ï¼‰</label>
        <input id="globalVendor" list="global-vendor-list" placeholder="è¼¸å…¥æˆ–é¸æ“‡å®¢æˆ¶/å» å•†" />
        <datalist id="global-vendor-list"></datalist>
        <div class="hint">æ­¤æ¬„ä½œç‚ºåˆ—è¡¨/åˆ†æé è¨­ç¯©é¸ï¼›å¯éš¨æ™‚æ¸…ç©ºã€‚</div>
      </div>
      <div style="min-width:260px;">
        <label>åˆ†æ”¤å¿«é€Ÿå‹•ä½œï¼ˆé‡å°ä¸Šæ–¹å®¢æˆ¶ï¼‰</label>
        <div class="row">
          <button class="btn" id="fifoAlloc">FIFO è‡ªå‹•åˆ†æ”¤</button>
          <button class="btn" id="clearAlloc">æ¸…ç©ºåˆ†æ”¤</button>
        </div>
      </div>
    </div>

    <div class="tabs" id="tabs"></div>
    <div id="panel-container" class="panel-container"></div>

    <div class="footer">è³‡æ–™çš†å„²å­˜åœ¨æ­¤ç€è¦½å™¨çš„ <span class="mono">localStorage</span>ï¼Œå¯é›¢ç·šä½¿ç”¨ã€‚å»ºè­°å®šæœŸã€ŒåŒ¯å‡ºå‚™ä»½ã€ã€‚</div>
  </div>

  <!-- Datalists for vendors -->
  <datalist id="all-vendor-list"></datalist>
  <datalist id="slip-vendor-list"></datalist>

<script>
(function(){
  // Global error handling
  window.onerror = function(message, source, lineno, colno, error) {
      console.error('Unhandled error:', { message, source, lineno, colno, error });
      alert('ç™¼ç”ŸéŒ¯èª¤ï¼š' + (error ? error.message : message) + '\nè«‹é‡æ–°æ•´ç†é é¢ã€‚');
      return true; // Prevent default error handling
  };
  window.onunhandledrejection = function(event) {
      console.error('Unhandled Promise rejection:', event.reason);
      alert('ç™¼ç”ŸéŒ¯èª¤ï¼š' + (event.reason ? event.reason.message || event.reason : 'æœªçŸ¥çš„ Promise éŒ¯èª¤') + '\nè«‹é‡æ–°æ•´ç†é é¢ã€‚');
      event.preventDefault(); // Prevent default error handling
  };

  // Utility: Debounce function
  function debounce(func, delay) {
    let timeout;
    return function(...args) {
      const context = this;
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(context, args), delay);
    };
  }

  // ===== Theme: auto-detect & toggle =====
  const THEME_KEY = 'fx-theme';
  const GLOBAL_VENDOR_KEY='fx-current-vendor';
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  const savedTheme = localStorage.getItem(THEME_KEY);
  const theme = savedTheme || (prefersDark ? 'dark' : 'light');
  setTheme(theme);
  document.getElementById('theme-btn').onclick = ()=>{
    setTheme(document.documentElement.getAttribute('data-theme')==='dark'?'light':'dark');
  };
  function setTheme(t){
    document.documentElement.setAttribute('data-theme', t);
    localStorage.setItem(THEME_KEY, t);
  }

  // ------------------ Data Layer ------------------
  const storeKey = 'fx-offline-v3';
  let state = {
    settings:{ rateMode:'mul', vendorHint:'', defaultCurrency:'USD', baseCurrency:'TWD' },
    slips:[], // æ°´å–®
    decls:[], // å ±å–®
    allocs:[], // åˆ†æ”¤: {id, declId, slipId, amount}
    audit:[], // ç¨½æ ¸: {id,time,action,entity,entityId,detail}
    _dataVersion: 0, // For caching
    _vendorCache: { all: null, slips: null, version: -1 },
  };

  async function saveAppState(){
    try{
      await localforage.setItem(storeKey, JSON.stringify(state));
    } catch (e) {
      if (e.name === 'QuotaExceededError') {
        alert('å„²å­˜ç©ºé–“å·²æ»¿ï¼Œè«‹æ¸…é™¤éƒ¨åˆ†è³‡æ–™æˆ–åŒ¯å‡ºå‚™ä»½å¾Œå†è©¦ã€‚');
      } else {
        console.error('Failed to save state:', e);
        alert('å„²å­˜è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š' + e.message);
      }
    }
  }
  async function loadAppState(){
    try{
      const data = await localforage.getItem(storeKey);
      if (data) {
        const loadedState = JSON.parse(data);
        // Ensure _dataVersion exists if loaded from old version
        if (typeof loadedState._dataVersion === 'undefined') {
            loadedState._dataVersion = 0;
        }
        return loadedState;
      }
    }catch(e){
      console.error('Failed to load state:', e);
      return null;
    }
    return null;
  }
  function incrementDataVersion() {
      state._dataVersion++;
      // Invalidate computeFx cache on all decls
      state.decls.forEach(d => delete d._fxResult);
  }
  function uid(){ return Math.random().toString(36).slice(2,10); }
  function nowISO(){ return new Date().toISOString(); }
  function log(action, entity, entityId, detail){
    state.audit.unshift({id:uid(), time:nowISO(), action, entity, entityId, detail});
    if(state.audit.length>2000) state.audit.length=2000;
  }
  function parseNum(x){ const n=Number(String(x).replace(/,/g,'')); return isFinite(n)?n:0; }
  function format(n, d=2){ return (isFinite(n)?n:0).toLocaleString(undefined,{minimumFractionDigits:d,maximumFractionDigits:d}); }
  
  function allVendors(){
    if (state._vendorCache.version !== state._dataVersion || !state._vendorCache.all) {
      const set=new Set([...(state.slips||[]).map(x=>x.vendor), ...(state.decls||[]).map(x=>x.vendor)]);
      state._vendorCache.all = Array.from(set).filter(Boolean).sort();
      state._vendorCache.version = state._dataVersion;
    }
    return state._vendorCache.all;
  }
  function slipVendors(){
    if (state._vendorCache.version !== state._dataVersion || !state._vendorCache.slips) {
      const set=new Set((state.slips||[]).map(x=>x.vendor));
      state._vendorCache.slips = Array.from(set).filter(Boolean).sort();
      state._vendorCache.version = state._dataVersion;
    }
    return state._vendorCache.slips;
  }

  // Allocation helpers
  function totalAllocatedForDecl(declId){ return state.allocs.filter(a=>a.declId===declId).reduce((s,a)=>s+parseNum(a.amount),0); }
  function totalAllocatedForSlip(slipId){ return state.allocs.filter(a=>a.slipId===slipId).reduce((s,a)=>s+parseNum(a.amount),0); }
  function slipAvailable(slip){ return Math.max(0, parseNum(slip.amount) - totalAllocatedForSlip(slip.id)); }
  function declAvailable(decl){ return Math.max(0, parseNum(decl.amount) - totalAllocatedForDecl(decl.id)); }

  // Compute FX (supports allocations) with caching
  function computeFx(decl){
    // Check if result is cached and still valid
    if (decl._fxResult && decl._fxResult.version === state._dataVersion) {
        return decl._fxResult;
    }

    const relevantAllocs = state.allocs.filter(a=>a.declId===decl.id);
    const rDecl = parseNum(decl.rate);

    if(relevantAllocs.length>0){
      let sumLocalSlip=0, sumLocalDecl=0;
      let arapList=[]; let stepLines=[];
      relevantAllocs.forEach(a=>{
        const slip = state.slips.find(s=>s.id===a.slipId); if(!slip) return;
        const rSlip = parseNum(slip.rate);
        const part = parseNum(a.amount);
        const localBySlip = state.settings.rateMode==='mul' ? part * rSlip : (rSlip? part / rSlip : 0);
        const localByDecl = state.settings.rateMode==='mul' ? part * rDecl : (rDecl? part / rDecl : 0);
        sumLocalSlip += localBySlip; sumLocalDecl += localByDecl;
        const slipDate = new Date(slip.date); const declDate=new Date(decl.date);
        arapList.push(slipDate < declDate ? 'é æ”¶ä»˜' : (slipDate > declDate ? 'æ‡‰æ”¶ä»˜' : 'åŒæ—¥'));
        const currencySymbol = decl.currency || 'å¤–å¹£';
        stepLines.push(`${format(part)}${currencySymbol} @ å ±å–®${format(rDecl,4)}-æ°´å–®${format(rSlip,4)} (å·®é¡: ${format(localByDecl-localBySlip)})`);
      });
      const diff = sumLocalDecl - sumLocalSlip;
      let label='', kind='';
      if(decl.type==='é€²å£'){
        label = diff>0 ? 'å…Œæ›ç›ˆé¤˜' : (diff<0 ? 'å…Œæ›æå¤±':'ç„¡å·®é¡');
        kind = diff>0 ? 'gain' : (diff<0 ? 'loss':'even');
      }else{ // å‡ºå£
        label = diff>0 ? 'å…Œæ›æå¤±' : (diff<0 ? 'å…Œæ›ç›ˆé¤˜':'ç„¡å·®é¡');
        kind = diff>0 ? 'loss' : (diff<0 ? 'gain':'even');
      }
      decl._fxResult = { version: state._dataVersion, slip:null, localBySlip:sumLocalSlip, localByDecl:sumLocalDecl, diff, label, kind, arap:arapList.join(' / '), steps:stepLines.join('\n') };
    } else {
        decl._fxResult = { version: state._dataVersion, slip:null, note:'å°šæœªåˆ†æ”¤', localBySlip:0, localByDecl:0, diff:0, label:'æœªåˆ†æ”¤', kind:'none', arap:null, steps:'å°šæœªé€²è¡Œåˆ†æ”¤ã€‚è«‹åœ¨å³å´ã€Œåˆ†æ”¤é…ç½®ã€å€å¡Šæ–°å¢æ°´å–®é€²è¡Œåˆ†é…ã€‚' };
    }
    return decl._fxResult;
  }

  // ------------------ UI Helpers ------------------
  const elTabs = document.getElementById('tabs');
  const elPanels = document.getElementById('panel-container');
  const tabs = [
    { id:'slip', name:'æ°´å–®ç®¡ç†' },
    { id:'decl', name:'é€²å‡ºå£å ±å–®' },
    { id:'fx',   name:'åŒ¯å·®åˆ†æ' },
    { id:'audit',name:'ç¨½æ ¸è»Œè·¡' },
    { id:'data', name:'è³‡æ–™ç®¡ç†' }
  ];
  let activeTab = 'slip';
  let selectedDeclForDetailId = null; // Store the ID of the decl to show detail for
  let expandedSlipId = null; // Store the ID of the slip whose allocations are expanded
  let currentPanelInstance = null; // To hold the currently active panel's methods

  function renderTabs(){
    elTabs.innerHTML = '';
    tabs.forEach(t=>{
      const b=document.createElement('button');
      b.className = 'tab'+(activeTab===t.id?' active':'');
      b.textContent = t.name;
      b.onclick = async ()=>{
        if (activeTab === t.id) return; // Prevent re-render if same tab
        activeTab=t.id;
        selectedDeclForDetailId = null; // Clear selected decl on tab change
        expandedSlipId = null; // Clear expanded slip on tab change
        await render();
      };
      elTabs.appendChild(b);
    })
  }

  // Helper for creating labelled input fields with unique IDs
  let fieldCounter = 0;
  function wrapField(labelText, inputEl){
      const wrapper = document.createElement('div');
      const label = document.createElement('label');
      const inputId = inputEl.id || `field-${fieldCounter++}`;
      inputEl.id = inputId;
      label.setAttribute('for', inputId);
      label.textContent = labelText;
      wrapper.appendChild(label);
      wrapper.appendChild(inputEl);
      return wrapper;
  }
  function button(text, kind, onclick){ const b=document.createElement('button'); b.className='btn '+(kind||''); b.textContent=text; b.onclick=onclick; return b; }
  function esc(s){ return String(s||'').replace(/[&<>\"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c])); }


  // Function to efficiently update table rows
  function updateTable(tbody, data, rowCreator, keyFn) {
    const existingRows = Array.from(tbody.children);
    const existingKeys = new Set(existingRows.map(row => row.dataset.id));
    const newKeys = new Set(data.map(keyFn));

    // Remove rows that no longer exist
    existingRows.forEach(row => {
      if (!newKeys.has(row.dataset.id)) {
        tbody.removeChild(row);
      }
    });

    // Add or update rows
    let currentHtmlIndex = 0;
    data.forEach(item => {
      const key = keyFn(item);
      let row = tbody.querySelector(`tr[data-id="${key}"]`);

      if (row) {
        // Update existing row (assuming rowCreator can handle updates, or just re-create)
        // For simplicity, we'll re-create for now if content changes often.
        // A more advanced approach would diff and update individual cells.
        // For this task, re-creating is fine as the number of rows isn't huge.
        const newRow = rowCreator(item);
        if (row.innerHTML !== newRow.innerHTML) { // Basic check for content change
            tbody.replaceChild(newRow, row);
            row = newRow;
        }
      } else {
        // Add new row
        row = rowCreator(item);
        row.dataset.id = key; // Ensure data-id is set
        // Insert in correct order
        if (currentHtmlIndex < tbody.children.length) {
            tbody.insertBefore(row, tbody.children[currentHtmlIndex]);
        } else {
            tbody.appendChild(row);
        }
      }
      currentHtmlIndex++;
    });
  }


  // ------------------ Panels ------------------

  // Panel component template
  function createPanel(id, mountFn, updateFn) {
    const wrapper = document.createElement('div');
    wrapper.id = `panel-${id}`;
    wrapper.className = 'panel-wrapper';
    mountFn(wrapper); // Initial mount

    return {
      element: wrapper,
      update: updateFn
    };
  }

  // --- Panel Slip ---
  function createPanelSlip(){
    const box = document.createElement('div'); box.className='grid';
    const newSlipForm = document.createElement('div'); newSlipForm.className='card panel-content-spacing';
    newSlipForm.innerHTML = `<h2>æ–°å¢æ°´å–®</h2>`;
    const row1 = document.createElement('div'); row1.className='grid cols-3';
    const date = document.createElement('input'); date.type='date'; date.id='newSlipDate';
    const currency = document.createElement('input'); currency.placeholder='å¹£åˆ¥ (å¦‚: USD)'; currency.value = state.settings.defaultCurrency; currency.id='newSlipCurrency';
    const rate = document.createElement('input'); rate.type='number'; rate.step='0.0001'; rate.id='newSlipRate';
    const amount = document.createElement('input'); amount.type='number'; amount.step='0.01'; amount.id='newSlipAmount';
    const vendor = document.createElement('input'); vendor.placeholder='å» å•†/å®¢æˆ¶'; vendor.setAttribute('list','all-vendor-list'); vendor.id='newSlipVendor';
    const note = document.createElement('input'); note.placeholder='å‚™è¨» (é¸å¡«)'; note.id='newSlipNote';

    row1.appendChild(wrapField('æ—¥æœŸ',date));
    row1.appendChild(wrapField('å¹£åˆ¥',currency));
    row1.appendChild(wrapField('åŒ¯ç‡',rate));
    row1.appendChild(wrapField('å¤–å¹£é‡‘é¡',amount));
    row1.appendChild(wrapField('å» å•†',vendor));
    row1.appendChild(wrapField('å‚™è¨»',note));
    const actions=document.createElement('div'); actions.className='right';
    const btn = button('æ–°å¢æ°´å–®','primary',async ()=>{
      if(!date.value||!vendor.value||!currency.value){ alert('è«‹å¡«å¯« æ—¥æœŸã€å¹£åˆ¥ èˆ‡ å» å•†'); return; }
      const obj={id:uid(), date:date.value, currency:currency.value.toUpperCase().trim(), rate:parseNum(rate.value), amount:parseNum(amount.value), vendor:vendor.value.trim(), note:note.value.trim()};
      state.slips.push(obj); log('æ–°å¢','æ°´å–®',obj.id, JSON.stringify(obj));
      incrementDataVersion();
      await saveAppState(); render('slip'); // Render 'slip' tab to update lists
    });
    actions.appendChild(btn);

    const batch = document.createElement('textarea'); batch.id='batchSlipInput';
    batch.placeholder = `æ‰¹é‡æ–°å¢ï¼šæ¯è¡Œè¼¸å…¥ã€Œæ—¥æœŸ,å¹£åˆ¥,åŒ¯ç‡,é‡‘é¡,å» å•†,å‚™è¨»ã€
ä¾‹å¦‚ï¼š
2025-01-05,USD,31.25,10000,Acme Ltd,TTåŒ¯å…¥
2025-01-08,JPY,0.215,500000,Acme Ltd,éƒ¨åˆ†é æ”¶`;
    const rowBatch = document.createElement('div'); rowBatch.className='row';
    rowBatch.appendChild(batch);
    const btnBatch = button('æ‰¹é‡åŒ¯å…¥æ°´å–®', 'warn', debounce(async ()=>{
      const lines = batch.value.split(/\n+/).map(s=>s.trim()).filter(Boolean);
      let ok=0, bad=0; const added=[];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const [d,c,r,a,v, n] = line.split(',').map(x=>x!=null?x.trim():x);
        if(d && c && v){ const obj={id:uid(), date:d, currency:c.toUpperCase(), rate:parseNum(r), amount:parseNum(a), vendor:v, note:n||''}; state.slips.push(obj); added.push(obj); ok++; } else bad++;
        if (i % 50 === 0) await new Promise(resolve => setTimeout(resolve, 0)); // Yield to UI
      }
      if(added.length) log('æ‰¹é‡åŒ¯å…¥','æ°´å–®','-', `${added.length} ç­†`);
      incrementDataVersion();
      await saveAppState();
      alert(`æˆåŠŸ ${ok} ç­†ï¼Œç•¥é ${bad} ç­†ã€‚`);
      render('slip'); // Render 'slip' tab to update lists
    }, 300)); // Debounce batch import
    rowBatch.appendChild(btnBatch);

    newSlipForm.appendChild(row1); newSlipForm.appendChild(actions);
    newSlipForm.appendChild(document.createElement('hr')); newSlipForm.appendChild(rowBatch);
    box.appendChild(newSlipForm);

    const list = document.createElement('div'); list.className='card';
    list.innerHTML = `<h2>æ°´å–®æ­·å²</h2>`;
    const filter = document.createElement('div'); filter.className='row';
    const fVendor = document.createElement('input'); fVendor.placeholder='æœå°‹å» å•†'; fVendor.setAttribute('list','all-vendor-list'); fVendor.id='slipFilterVendor';
    const fFrom = document.createElement('input'); fFrom.type='date'; fFrom.id='slipFilterFrom';
    const fTo = document.createElement('input'); fTo.type='date'; fTo.id='slipFilterTo';
    filter.appendChild(wrapField('å» å•†', fVendor));
    filter.appendChild(wrapField('èµ·', fFrom));
    filter.appendChild(wrapField('è¿„', fTo));
    list.appendChild(filter);

    const tbl = document.createElement('table');
    const thead = document.createElement('thead'); thead.innerHTML = `<tr><th>æ—¥æœŸ</th><th>å» å•†</th><th class="small">å¹£åˆ¥</th><th class="small">åŒ¯ç‡</th><th class="small">å¤–å¹£é‡‘é¡</th><th>å¯ç”¨é‡‘é¡</th><th>å‚™è¨»</th><th>å‹•ä½œ</th></tr>`; tbl.appendChild(thead);
    const tbody = document.createElement('tbody'); tbl.appendChild(tbody);

    const drawBody = ()=>{
      const filteredSlips = state.slips
        .filter(s=>!fVendor.value || (s.vendor||'').toLowerCase().includes(fVendor.value.toLowerCase()))
        .filter(s=>!fFrom.value || new Date(s.date)>=new Date(fFrom.value))
        .filter(s=>!fTo.value || new Date(s.date)<=new Date(fTo.value))
        .sort((a,b)=>new Date(b.date)-new Date(a.date));

      const rowCreator = (s) => {
        const tr=document.createElement('tr');
        tr.dataset.id = s.id;
        tr.innerHTML = `<td>${s.date}</td><td>${esc(s.vendor)}</td><td>${esc(s.currency||'N/A')}</td><td>${format(s.rate,4)}</td><td>${format(s.amount)}</td><td>${format(slipAvailable(s))}</td><td>${esc(s.note||'')}</td>`;
        const td=document.createElement('td');
        const viewAllocBtn = button('æŸ¥çœ‹åˆ†æ”¤','ghost',null); // Click handled by delegation
        viewAllocBtn.dataset.action = 'toggle-alloc';
        viewAllocBtn.dataset.slipId = s.id;

        const del=button('åˆªé™¤','danger',null); // Click handled by delegation
        del.dataset.action = 'delete-slip';
        del.dataset.slipId = s.id;
        td.appendChild(viewAllocBtn);
        td.appendChild(del); tr.appendChild(td);

        if (expandedSlipId === s.id) {
            const allocDetailRow = document.createElement('tr');
            allocDetailRow.className = 'allocation-detail-row';
            allocDetailRow.innerHTML = `<td colspan="8">
              <div class="allocation-detail-content card">
                <h4>å·²åˆ†é…è‡³å ±å–®ï¼š</h4>
                <table style="width:100%">
                  <thead><tr><th>å ±å–®æ—¥æœŸ</th><th>å» å•†</th><th>é¡å‹</th><th>åˆ†æ”¤é‡‘é¡(å¤–å¹£)</th><th></th></tr></thead>
                  <tbody></tbody>
                </table>
              </div>
            </td>`;
            const allocTbody = allocDetailRow.querySelector('tbody');
            const relevantAllocs = state.allocs.filter(a => a.slipId === s.id);
            if (relevantAllocs.length === 0) {
              allocTbody.innerHTML = `<tr><td colspan="5" class="muted">ç„¡åˆ†æ”¤ç´€éŒ„</td></tr>`;
            } else {
              relevantAllocs.forEach(alloc => {
                const decl = state.decls.find(d => d.id === alloc.declId);
                if (decl) {
                  const allocTr = document.createElement('tr');
                  allocTr.innerHTML = `
                    <td>${decl.date}</td>
                    <td>${esc(decl.vendor)}</td>
                    <td>${decl.type}</td>
                    <td>${format(alloc.amount)} ${decl.currency||'N/A'}</td>
                  `;
                  const viewDeclTd = document.createElement('td');
                  const viewDeclBtn = button('æŸ¥çœ‹å ±å–®','ghost',null); // Click handled by delegation
                  viewDeclBtn.dataset.action = 'view-decl-from-slip';
                  viewDeclBtn.dataset.declId = decl.id;
                  viewDeclTd.appendChild(viewDeclBtn);
                  allocTr.appendChild(viewDeclTd);
                  allocTbody.appendChild(allocTr);
                }
              });
            }
            const wrapper = document.createElement('div');
            wrapper.appendChild(tr);
            wrapper.appendChild(allocDetailRow);
            return wrapper; // Return a fragment containing both rows
        }
        return tr;
      };

      // Create a temporary container to handle fragments correctly with updateTable
      const tempTbody = document.createElement('tbody');
      filteredSlips.forEach(s => {
        const rowOrFragment = rowCreator(s);
        if (rowOrFragment.nodeType === Node.DOCUMENT_FRAGMENT_NODE || rowOrFragment.children) { // Handle fragments/div wrappers
            Array.from(rowOrFragment.children).forEach(child => tempTbody.appendChild(child));
        } else {
            tempTbody.appendChild(rowOrFragment);
        }
      });
      tbody.innerHTML = tempTbody.innerHTML; // A simpler approach given the fragment complexity

      // Delegation for actions on slip list
      tbody.onclick = async (event) => {
        const target = event.target;
        const buttonAction = target.dataset.action;
        const slipId = target.dataset.slipId || target.closest('tr[data-id]')?.dataset.id;
        const declId = target.dataset.declId;

        if (buttonAction === 'toggle-alloc') {
          expandedSlipId = (expandedSlipId === slipId) ? null : slipId;
          render('slip'); // Re-render to show/hide the allocation detail
        } else if (buttonAction === 'delete-slip') {
          if(confirm('ç¢ºå®šåˆªé™¤ï¼Ÿ')){
            const slipToDelete = state.slips.find(x => x.id === slipId);
            if (slipToDelete) {
                log('åˆªé™¤', 'æ°´å–®', slipId, JSON.stringify(slipToDelete));
                state.slips = state.slips.filter(x => x.id !== slipId);
                state.allocs = state.allocs.filter(a => a.slipId !== slipId);
                incrementDataVersion();
                await saveAppState(); render('slip');
            }
          }
        } else if (buttonAction === 'view-decl-from-slip') {
            activeTab='fx'; selectedDeclForDetailId = declId; await render();
        }
      };
    };

    [fVendor,fFrom,fTo].forEach(el=>el.oninput=debounce(drawBody, 300));
    list.appendChild(tbl); box.appendChild(list);

    const updatePanel = () => {
      fVendor.value = (localStorage.getItem(GLOBAL_VENDOR_KEY)||'').trim(); // Update filter from global
      drawBody();
    };

    return createPanel('slip', (el) => {
        el.appendChild(box);
    }, updatePanel);
  }

  // --- Panel Decl ---
  function createPanelDecl(){
    const box = document.createElement('div'); box.className='grid';

    const newDeclForm = document.createElement('div'); newDeclForm.className='card panel-content-spacing'; newDeclForm.innerHTML='<h2>æ–°å¢é€²å‡ºå£å ±å–®</h2>';
    const row = document.createElement('div'); row.className='grid cols-3';
    const date = document.createElement('input'); date.type='date'; date.id='newDeclDate';
    const currency = document.createElement('input'); currency.placeholder='å¹£åˆ¥ (å¦‚: USD)'; currency.value = state.settings.defaultCurrency; currency.id='newDeclCurrency';
    const rate = document.createElement('input'); rate.type='number'; rate.step='0.0001'; rate.id='newDeclRate';
    const amount = document.createElement('input'); amount.type='number'; amount.step='0.01'; amount.id='newDeclAmount';
    const vendor = document.createElement('input'); vendor.placeholder='å» å•†/å®¢æˆ¶'; vendor.setAttribute('list','slip-vendor-list'); vendor.id='newDeclVendor';
    const type = document.createElement('select'); type.id='newDeclType'; type.innerHTML = '<option value="é€²å£">é€²å£</option><option value="å‡ºå£">å‡ºå£</option>';
    const note = document.createElement('input'); note.placeholder='å‚™è¨» (é¸å¡«)'; note.id='newDeclNote';

    row.appendChild(wrapField('æ—¥æœŸ',date));
    row.appendChild(wrapField('å¹£åˆ¥',currency));
    row.appendChild(wrapField('åŒ¯ç‡',rate));
    row.appendChild(wrapField('å¤–å¹£é‡‘é¡',amount));
    row.appendChild(wrapField('å» å•†',vendor));
    row.appendChild(wrapField('é¡å‹',type));
    row.appendChild(wrapField('å‚™è¨»',note));

    const actions=document.createElement('div'); actions.className='right';
    const btn = button('æ–°å¢å ±å–®','primary',async ()=>{
      if(!date.value||!vendor.value||!currency.value){ alert('è«‹å¡«å¯« æ—¥æœŸã€å¹£åˆ¥ èˆ‡ å» å•†'); return; }
      if (!slipVendors().includes(vendor.value.trim())) {
        alert('è«‹å¾ç¾æœ‰çš„æ°´å–®å» å•†ä¸­é¸æ“‡ï¼Œæˆ–å…ˆåˆ°æ°´å–®ç®¡ç†æ–°å¢è©²å» å•†ã€‚');
        return;
      }
      const obj={id:uid(), date:date.value, currency:currency.value.toUpperCase().trim(), rate:parseNum(rate.value), amount:parseNum(amount.value), vendor:vendor.value.trim(), type:type.value, note:note.value.trim()};
      state.decls.push(obj); log('æ–°å¢','å ±å–®',obj.id, JSON.stringify(obj));
      incrementDataVersion();
      await saveAppState(); render('decl');
    });
    actions.appendChild(btn);

    const batch = document.createElement('textarea'); batch.id='batchDeclInput';
    batch.placeholder = `æ‰¹é‡æ–°å¢ï¼šæ¯è¡Œã€Œæ—¥æœŸ,å¹£åˆ¥,åŒ¯ç‡,é‡‘é¡,å» å•†,é¡å‹(é€²å£/å‡ºå£),å‚™è¨»ã€
ä¾‹å¦‚ï¼š
2025-01-09,USD,31.50,8000,Acme Ltd,é€²å£,1æœˆé€²å£
2025-01-12,JPY,0.218,1200000,Acme Ltd,å‡ºå£,1æœˆå‡ºå£`;
    const rowBatch = document.createElement('div'); rowBatch.className='row';
    rowBatch.appendChild(batch);
    const btnBatch = button('æ‰¹é‡åŒ¯å…¥å ±å–®', 'warn', debounce(async ()=>{
      const lines = batch.value.split(/\n+/).map(s=>s.trim()).filter(Boolean);
      let ok=0, bad=0;
      const validSlipVendors = new Set(slipVendors());
      const addedDecls = [];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const [d,c,r,a,v,t,n] = line.split(',').map(x=>x!=null?x.trim():x);
        if(d && c && v && (t==='é€²å£'||t==='å‡ºå£') && validSlipVendors.has(v)){
          const obj={id:uid(), date:d, currency:c.toUpperCase(), rate:parseNum(r), amount:parseNum(a), vendor:v, type:t, note:n||''};
          state.decls.push(obj); addedDecls.push(obj); ok++;
        } else bad++;
        if (i % 50 === 0) await new Promise(resolve => setTimeout(resolve, 0)); // Yield to UI
      }
      if(addedDecls.length) log('æ‰¹é‡æ–°å¢','å ±å–®','-', `${addedDecls.length} ç­†`);
      incrementDataVersion();
      await saveAppState(); alert(`æˆåŠŸ ${ok} ç­†ï¼Œç•¥é ${bad} ç­† (å¯èƒ½å› å» å•†åç¨±ä¸åœ¨æ°´å–®ç´€éŒ„ä¸­)ã€‚`);
      render('decl');
    }, 300));
    rowBatch.appendChild(btnBatch);

    newDeclForm.appendChild(row);
    newDeclForm.appendChild(actions); newDeclForm.appendChild(document.createElement('hr')); newDeclForm.appendChild(rowBatch);
    box.appendChild(newDeclForm);

    const list = document.createElement('div'); list.className='card';
    list.innerHTML = `<h2>å ±å–®æ­·å²</h2>`;
    const filter = document.createElement('div'); filter.className='row';
    const fVendor = document.createElement('input'); fVendor.placeholder='æœå°‹å» å•†'; fVendor.setAttribute('list','all-vendor-list'); fVendor.id='declFilterVendor';
    const fType = document.createElement('select'); fType.id='declFilterType'; fType.innerHTML='<option value="">å…¨éƒ¨</option><option>é€²å£</option><option>å‡ºå£</option>';
    const fFrom = document.createElement('input'); fFrom.type='date'; fFrom.id='declFilterFrom';
    const fTo = document.createElement('input'); fTo.type='date'; fTo.id='declFilterTo';
    filter.appendChild(wrapField('å» å•†', fVendor));
    filter.appendChild(wrapField('é¡å‹', fType));
    filter.appendChild(wrapField('èµ·', fFrom));
    filter.appendChild(wrapField('è¿„', fTo));
    list.appendChild(filter);

    const tbl = document.createElement('table');
    const thead = document.createElement('thead'); thead.innerHTML = `<tr><th>æ—¥æœŸ</th><th>é¡å‹</th><th>å» å•†</th><th class="small">å¹£åˆ¥</th><th>åŒ¯ç‡</th><th>å¤–å¹£é‡‘é¡</th><th>å·²åˆ†æ”¤</th><th>åˆ†æ”¤æ°´å–®</th><th></th></tr>`; tbl.appendChild(thead);
    const tbody = document.createElement('tbody'); tbl.appendChild(tbody);

    const drawBody = ()=>{
      const filteredDecls = state.decls
        .filter(s=>!fVendor.value || (s.vendor||'').toLowerCase().includes(fVendor.value.toLowerCase()))
        .filter(s=>!fType.value || s.type===fType.value)
        .filter(s=>!fFrom.value || new Date(s.date)>=new Date(fFrom.value))
        .filter(s=>!fTo.value || new Date(s.date)<=new Date(fTo.value))
        .sort((a,b)=>new Date(b.date)-new Date(a.date));

      const rowCreator = (d) => {
        const tr=document.createElement('tr');
        tr.dataset.id = d.id;
        tr.dataset.action = 'select-decl'; // For delegation
        const totalAllocated = totalAllocatedForDecl(d.id);
        const slipTxt = totalAllocated > 0 ? `å·²åˆ†æ”¤ (${format(totalAllocated)} ${d.currency||'å¤–å¹£'})` : 'æœªåˆ†æ”¤';
        tr.innerHTML = `<td>${d.date}</td><td>${d.type}</td><td>${esc(d.vendor)}</td><td>${esc(d.currency||'N/A')}</td><td>${format(d.rate,4)}</td><td>${format(d.amount)}</td><td>${format(totalAllocated)}</td><td class="small">${slipTxt}</td>`;
        const td=document.createElement('td');
        const del=button('åˆªé™¤','danger',null); // Click handled by delegation
        del.dataset.action = 'delete-decl';
        del.dataset.declId = d.id;
        td.appendChild(del); tr.appendChild(td);
        return tr;
      };
      updateTable(tbody, filteredDecls, rowCreator, (d) => d.id);

      // Delegation for actions on decl list
      tbody.onclick = async (event) => {
        const target = event.target;
        const buttonAction = target.dataset.action;
        const declId = target.dataset.declId || target.closest('tr[data-id]')?.dataset.id;
        const decl = state.decls.find(d => d.id === declId);

        if (buttonAction === 'delete-decl') {
          if(confirm('ç¢ºå®šåˆªé™¤ï¼Ÿ')){
            if (decl) {
                log('åˆªé™¤','å ±å–®',decl.id, JSON.stringify(decl));
                state.decls=state.decls.filter(x=>x.id!==decl.id);
                state.allocs=state.allocs.filter(a=>a.declId!==decl.id);
                incrementDataVersion();
                await saveAppState(); render('decl');
            }
          }
        } else if (declId) { // Click on a row
          activeTab='fx'; selectedDeclForDetailId = declId; await render();
        }
      };
    };

    [fVendor,fType,fFrom,fTo].forEach(el=>el.oninput=debounce(drawBody, 300));
    list.appendChild(tbl); box.appendChild(list);

    const updatePanel = () => {
      fVendor.value = (localStorage.getItem(GLOBAL_VENDOR_KEY)||'').trim(); // Update filter from global
      drawBody();
    };
    return createPanel('decl', (el) => {
        el.appendChild(box);
    }, updatePanel);
  }

  // --- Panel Fx ---
  function createPanelFx(){
    const box = document.createElement('div'); box.className='split';

    const left = document.createElement('div'); left.className='grid';
    const p = document.createElement('div'); p.className='card'; p.innerHTML = '<h2>åŒ¯å·®åˆ†æ</h2>';

    const filter = document.createElement('div'); filter.className='row';
    const fVendor = document.createElement('input'); fVendor.placeholder='æœå°‹å» å•†'; fVendor.setAttribute('list','all-vendor-list'); fVendor.id='fxFilterVendor';
    const fType = document.createElement('select'); fType.id='fxFilterType'; fType.innerHTML='<option value="">å…¨éƒ¨</option><option>é€²å£</option><option>å‡ºå£</option>';
    const fFrom = document.createElement('input'); fFrom.type='date'; fFrom.id='fxFilterFrom';
    const fTo = document.createElement('input'); fTo.type='date'; fTo.id='fxFilterTo';
    filter.appendChild(wrapField('å» å•†', fVendor));
    filter.appendChild(wrapField('é¡å‹', fType));
    filter.appendChild(wrapField('èµ·', fFrom));
    filter.appendChild(wrapField('è¿„', fTo));
    p.appendChild(filter);

    const tbl = document.createElement('table');
    const thead = document.createElement('thead'); thead.innerHTML='<tr><th>æ—¥æœŸ</th><th>é¡å‹</th><th>å» å•†</th><th class="small">å¹£åˆ¥</th><th>é‡‘é¡(å¤–å¹£)</th><th>å ±å–®åŒ¯ç‡</th><th>åˆ†æ”¤æ°´å–®æ•¸</th><th>å·®é¡</th><th>åˆ¤æ–·</th></tr>';
    tbl.appendChild(thead);
    const tbody = document.createElement('tbody'); tbl.appendChild(tbody);

    const sumBar = document.createElement('div'); sumBar.className='hint'; p.appendChild(sumBar);
    left.appendChild(p);

    const right = document.createElement('div'); right.className='card sticky';
    right.innerHTML='<h2>æ˜ç´° / è¨ˆç®—éç¨‹</h2><div id="detail" class="small muted">é»æ“Šå·¦å´ä»»ä¸€ç­†è³‡æ–™ä»¥æŸ¥çœ‹</div><div id="alloc" class="panel-content-spacing"></div>';
    box.appendChild(left); box.appendChild(right);

    const detailBox = right.querySelector('#detail');
    const allocBox = right.querySelector('#alloc');

    const drawBody = ()=>{
      const filtered = state.decls
        .filter(s=>!fVendor.value || (s.vendor||'').toLowerCase().includes(fVendor.value.toLowerCase()))
        .filter(s=>!fType.value || s.type===fType.value)
        .filter(s=>!fFrom.value || new Date(s.date)>=new Date(fFrom.value))
        .filter(s=>!fTo.value || new Date(s.date)<=new Date(fTo.value))
        .sort((a,b)=>new Date(b.date)-new Date(a.date));

      let sumGain=0, sumLoss=0;

      const rowCreator = (d) => {
        const r = computeFx(d);
        const tr=document.createElement('tr');
        tr.dataset.id = d.id;
        const numSlipsAllocated = state.allocs.filter(a=>a.declId===d.id).length;
        tr.innerHTML = `<td>${d.date}</td><td>${d.type}</td><td>${esc(d.vendor)}</td><td>${esc(d.currency||'N/A')}</td><td>${format(d.amount)}</td><td>${format(d.rate,4)}</td><td>${numSlipsAllocated || '-'}</td>`;
        const tdDiff = document.createElement('td');
        tdDiff.innerHTML = `<span class="mono" style="font-size:1.1rem; font-weight:700;">${format(Math.abs(r.diff))}</span>`; /* Highlighted */
        const tdLabel = document.createElement('td');
        const pill = document.createElement('span'); pill.className='pill '+(r.kind==='gain'?'gain':(r.kind==='loss'?'loss':'')); pill.textContent=r.label;
        tdLabel.appendChild(pill);
        tr.appendChild(tdDiff); tr.appendChild(tdLabel);
        if(r.kind==='gain') sumGain += Math.abs(r.diff);
        if(r.kind==='loss') sumLoss += Math.abs(r.diff);
        return tr;
      };

      updateTable(tbody, filtered, rowCreator, (d) => d.id);
      sumBar.textContent = `ç¸½ç›ˆé¤˜ï¼š${format(sumGain)} ï½œ ç¸½æå¤±ï¼š${format(sumLoss)}`;

      // Event delegation for table clicks
      tbody.onclick = (event) => {
          const clickedRow = event.target.closest('tr[data-id]');
          if (clickedRow) {
              const declId = clickedRow.dataset.id;
              const decl = state.decls.find(d => d.id === declId);
              if (decl) showDetail(decl);
          }
      };
    };

    const showDetail = async (d) => {
      // Remove 'is-selected' from previously selected row
      const prevSelectedRow = tbody.querySelector('tr.is-selected');
      if (prevSelectedRow) prevSelectedRow.classList.remove('is-selected');
      // Add 'is-selected' to current row
      const currentRow = tbody.querySelector(`tr[data-id="${d.id}"]`);
      if (currentRow) currentRow.classList.add('is-selected');

      const r = computeFx(d);
      if(!r){ detailBox.textContent='ç™¼ç”ŸéŒ¯èª¤'; return; }
      detailBox.className='small';
      const currencySymbol = d.currency || 'å¤–å¹£';
      const slipInfo = state.allocs.filter(a=>a.declId===d.id).length > 0 ? `å·²åˆ†æ”¤å¤šç­†æ°´å–®` : 'å°šæœªåˆ†æ”¤';
      detailBox.innerHTML = `
      <div class="grid">
        <div><label>å ±å–®</label><div class="mono">${d.date}ï½œ${d.type}ï½œ${esc(d.vendor)}ï½œå¤–å¹£ ${currencySymbol} ${format(d.amount)}ï½œåŒ¯ç‡ ${format(d.rate,4)}</div></div>
        <div><label>é…å°æ°´å–®</label><div class="mono">${slipInfo}</div></div>
        <div><label>æ‡‰æ”¶æ‡‰ä»˜åˆ¤å®š</label><div>${r.arap||'â€”'}</div></div>
        <div><label>åˆ¤æ–·</label><div><span class="pill ${r.kind==='gain'?'gain':(r.kind==='loss'?'loss':'')}">${r.label}</span></div></div>
        <div><label>å·®é¡çµ•å°å€¼ï¼ˆæœ¬å¹£ï¼‰</label><div class="mono" style="font-size:1.2rem; font-weight:700;">${format(Math.abs(r.diff))}</div></div>
        <div><label>è¨ˆç®—éç¨‹</label><pre class="mono" style="white-space:pre-wrap;background:var(--panel-2);border:1px solid var(--border);padding:8px;border-radius:10px">${esc(r.steps||'â€”')}</pre></div>
      </div>`;

      // åˆ†æ”¤é…ç½® UI
      const sameVendorSlips = state.slips.filter(s=>s.vendor===d.vendor && s.currency===d.currency).sort((a,b)=>new Date(a.date)-new Date(b.date));
      const currentAllocs = state.allocs.filter(a=>a.declId===d.id);
      const totalAvailDecl = declAvailable(d);
      allocBox.innerHTML = '';
      const wrap = document.createElement('div'); wrap.className='card';
      const title = document.createElement('h2'); title.textContent='éƒ¨åˆ†æ²–éŠ· / åˆ†æ”¤é…ç½®'; wrap.appendChild(title);
      const hint = document.createElement('div'); hint.className='hint'; hint.textContent='å¯ç‚ºæ­¤å ±å–®åˆ†é…å¤šç­†æ°´å–®èˆ‡åˆ†æ”¤å¤–å¹£é‡‘é¡ã€‚è‹¥æœªè¨­å®šåˆ†æ”¤ï¼Œå‰‡åŒ¯å·®çµæœç‚ºé›¶ã€‚'; wrap.appendChild(hint);

      const allocTbl = document.createElement('table');
      allocTbl.innerHTML = '<thead><tr><th>æ°´å–®æ—¥æœŸ</th><th>å¹£åˆ¥</th><th>åŒ¯ç‡</th><th>æ°´å–®å¯ç”¨(å¤–å¹£)</th><th>åˆ†æ”¤é‡‘é¡(å¤–å¹£)</th><th></th></tr></thead>';
      const allocTbody = document.createElement('tbody');
      currentAllocs.forEach(a=>{
        const slip = state.slips.find(s=>s.id===a.slipId); if(!slip) return;
        const tr=document.createElement('tr');
        tr.dataset.id = a.id;
        tr.innerHTML = `<td>${slip.date}</td><td>${esc(slip.currency||'N/A')}</td><td>${format(slip.rate,4)}</td><td>${format(slipAvailable(slip) + parseNum(a.amount))}</td>`; // Show total available including current allocation
        const tdAmt = document.createElement('td');
        const inp = document.createElement('input'); inp.type='number'; inp.step='0.01'; inp.value=a.amount; inp.id = `alloc-${a.id}`;
        inp.onchange=debounce(async ()=>{
          const newAmount = parseNum(inp.value);
          const oldAmount = parseNum(a.amount);
          const max = slipAvailable(slip) + oldAmount; // Available including currently allocated amount
          if(newAmount < 0){ alert('é‡‘é¡éœ€å¤§æ–¼ 0'); inp.value = oldAmount; return; }
          if(newAmount > max){ alert(`è¶…éå¯åˆ†é…é‡‘é¡ï¼Œæœ€å¤§å¯åˆ†é…ï¼š${format(max)} ${currencySymbol}`); inp.value = oldAmount; return; }
          a.amount=newAmount;
          log('ä¿®æ”¹åˆ†æ”¤','åˆ†æ”¤',a.id, `æ–°é‡‘é¡ ${a.amount}`);
          incrementDataVersion();
          await saveAppState(); showDetail(d); // Re-render detail
        }, 300);
        tdAmt.appendChild(inp); tr.appendChild(tdAmt);
        const tdAct=document.createElement('td');
        const del=button('ç§»é™¤','danger',async ()=>{
          state.allocs=state.allocs.filter(x=>x.id!==a.id); log('ç§»é™¤åˆ†æ”¤','åˆ†æ”¤',a.id, JSON.stringify(a));
          incrementDataVersion();
          await saveAppState(); showDetail(d);
        });
        tdAct.appendChild(del); tr.appendChild(tdAct);
        allocTbody.appendChild(tr);
      });
      allocTbl.appendChild(allocTbody); wrap.appendChild(allocTbl);

      // Add new allocation controls
      const addRow = document.createElement('div'); addRow.className='row';
      const sel = document.createElement('select'); sel.id='allocSlipSelect';
      sel.innerHTML = sameVendorSlips.map(s=>`<option value="${s.id}">${s.date}ï½œ${esc(s.currency||'N/A')}ï½œå¯ç”¨${format(slipAvailable(s))}ï½œåŒ¯ç‡${format(s.rate,4)}</option>`).join('');
      const addAmt = document.createElement('input'); addAmt.type='number'; addAmt.step='0.01'; addAmt.placeholder='åˆ†æ”¤å¤–å¹£é‡‘é¡'; addAmt.id='allocAmountInput';
      addRow.appendChild(wrapField('é¸æ“‡æ°´å–®', sel));
      addRow.appendChild(wrapField('é‡‘é¡(å¤–å¹£)', addAmt));
      const addBtn = button('æ–°å¢åˆ†æ”¤','primary',async ()=>{
        const slip = state.slips.find(s=>s.id===sel.value);
        if(!slip){ alert('è«‹é¸æ“‡æ°´å–®'); return; }
        if(slip.currency !== d.currency){ alert('æ°´å–®èˆ‡å ±å–®å¹£åˆ¥ä¸ç¬¦ï¼Œç„¡æ³•åˆ†æ”¤ã€‚'); return; }
        const want = parseNum(addAmt.value);
        if(want<=0){ alert('é‡‘é¡éœ€å¤§æ–¼ 0'); return; }
        const max = Math.min(slipAvailable(slip), declAvailable(d));
        if(want>max){ alert(`è¶…éå¯åˆ†é…é‡‘é¡ï¼Œæœ€å¤§å¯åˆ†é…ï¼š${format(max)} ${currencySymbol}`); return; }
        const obj={id:uid(), declId:d.id, slipId:slip.id, amount:want};
        state.allocs.push(obj); log('æ–°å¢åˆ†æ”¤','åˆ†æ”¤',obj.id, JSON.stringify(obj));
        incrementDataVersion();
        await saveAppState(); showDetail(d);
      });
      addRow.appendChild(addBtn);
      wrap.appendChild(addRow);

      const info = document.createElement('div'); info.className='hint'; info.textContent = `æ­¤å ±å–®å‰©é¤˜å¯åˆ†é…ï¼š${format(totalAvailDecl)} ${currencySymbol}`;
      wrap.appendChild(info);

      allocBox.appendChild(wrap);
    };

    [fVendor,fType,fFrom,fTo].forEach(el=>el.oninput=debounce(drawBody, 300));

    // helper: auto FIFO distribute within vendor context
    async function autoFIFO(vendor){
      const decls = state.decls.filter(d=>!vendor || d.vendor===vendor).sort((a,b)=>new Date(a.date)-new Date(b.date));
      const slips = state.slips.filter(s=>!vendor || s.vendor===vendor).sort((a,b)=>new Date(a.date)-new Date(b.date));
      // reset vendor-related allocs
      if(vendor){
        const allocsToRemove = new Set();
        state.decls.filter(d => d.vendor === vendor).forEach(d => {
          state.allocs.filter(a => a.declId === d.id).forEach(a => allocsToRemove.add(a.id));
        });
        state.allocs = state.allocs.filter(a => !allocsToRemove.has(a.id));
      }

      let si=0;
      let logs = [];
      for (let i = 0; i < decls.length; i++) {
        const d = decls[i];
        let need = declAvailable(d);
        while(need>0 && si<slips.length){
          const s = slips[si];
          if (s.currency !== d.currency) {
              si++;
              continue;
          }
          let avail = slipAvailable(s);
          if(avail<=0){ si++; continue; }
          const take = Math.min(need, avail);
          const obj={id:uid(), declId:d.id, slipId:s.id, amount:take};
          state.allocs.push(obj); need -= take; logs.push({action:'FIFOåˆ†æ”¤',entity:'åˆ†æ”¤',entityId:obj.id, detail:`${d.id} â‡„ ${s.id} / ${take}`});
          if(slipAvailable(s)<=0) si++;
        }
        if (i % 50 === 0) await new Promise(resolve => setTimeout(resolve, 0)); // Yield
      }
      logs.forEach(l => log(l.action, l.entity, l.entityId, l.detail));
      incrementDataVersion();
      await saveAppState(); render();
    }

    // Wire quickbar buttons to current vendor
    const fifoBtn = document.getElementById('fifoAlloc');
    if(fifoBtn) fifoBtn.onclick = async ()=>{
        const v=(localStorage.getItem(GLOBAL_VENDOR_KEY)||'').trim();
        await autoFIFO(v||null);
    };
    const clearBtn = document.getElementById('clearAlloc');
    if(clearBtn) clearBtn.onclick = async ()=>{
        if(confirm('ç¢ºå®šæ¸…ç©ºæ‰€æœ‰åˆ†æ”¤ï¼Ÿæ­¤æ“ä½œç„¡æ³•æ’¤éŠ·ã€‚')){
            state.allocs=[]; log('æ¸…ç©º','åˆ†æ”¤','-','å…¨éƒ¨æ¸…é™¤');
            incrementDataVersion();
            await saveAppState(); render();
        }
    };

    const updatePanel = () => {
      fVendor.value = (localStorage.getItem(GLOBAL_VENDOR_KEY)||'').trim(); // Update filter from global
      drawBody();
      if (selectedDeclForDetailId) {
        const decl = state.decls.find(d => d.id === selectedDeclForDetailId);
        if (decl) showDetail(decl);
        selectedDeclForDetailId = null; // Clear after processing
      } else {
        // If no specific decl selected, clear detail view
        detailBox.innerHTML = '<div class="small muted">é»æ“Šå·¦å´ä»»ä¸€ç­†è³‡æ–™ä»¥æŸ¥çœ‹</div>';
        allocBox.innerHTML = '';
        const prevSelectedRow = tbody.querySelector('tr.is-selected');
        if (prevSelectedRow) prevSelectedRow.classList.remove('is-selected');
      }
    };

    return createPanel('fx', (el) => {
        el.appendChild(box);
    }, updatePanel);
  }

  // --- Panel Audit ---
  function createPanelAudit(){
    const box=document.createElement('div'); box.className='card';
    box.innerHTML='<h2>ç¨½æ ¸è»Œè·¡</h2>';
    const hint=document.createElement('div'); hint.className='hint'; hint.textContent='è¨˜éŒ„æ–°å¢/åˆªé™¤/æ‰¹é‡åŒ¯å…¥/åˆ†æ”¤ç­‰æ“ä½œï¼ˆåƒ…å­˜æœ¬æ©Ÿï¼‰ã€‚'; box.appendChild(hint);
    const tbl=document.createElement('table');
    tbl.innerHTML='<thead><tr><th>æ™‚é–“</th><th>å‹•ä½œ</th><th>é¡å‹</th><th>ID</th><th>èªªæ˜</th></tr></thead>';
    const tbody=document.createElement('tbody'); tbl.appendChild(tbody);
    box.appendChild(tbl);

    const drawBody = () => {
        const rowCreator = (a) => {
            const tr=document.createElement('tr');
            tr.dataset.id = a.id;
            const t = new Date(a.time).toLocaleString();
            tr.innerHTML=`<td>${t}</td><td>${esc(a.action)}</td><td>${esc(a.entity)}</td><td class="mono">${esc(a.entityId)}</td><td class="small">${esc(a.detail||'')}</td>`;
            return tr;
        };
        updateTable(tbody, state.audit, rowCreator, (a) => a.id);
    };

    return createPanel('audit', (el) => {
        el.appendChild(box);
    }, drawBody);
  }

  // --- Panel Data ---
  function createPanelData(){
    const box = document.createElement('div'); box.className='grid';

    const s = document.createElement('div'); s.className='card'; s.innerHTML='<h2>ç³»çµ±è¨­å®š</h2>';
    const mode = document.createElement('select'); mode.id='settingRateMode'; mode.innerHTML='<option value="mul">æœ¬å¹£=å¤–å¹£Ã—åŒ¯ç‡</option><option value="div">æœ¬å¹£=å¤–å¹£Ã·åŒ¯ç‡</option>';
    mode.value = state.settings.rateMode;
    mode.onchange = async ()=>{
      state.settings.rateMode=mode.value; log('ä¿®æ”¹è¨­å®š','ç³»çµ±','rateMode', mode.value);
      incrementDataVersion();
      await saveAppState(); // No need to full render, just save
    };

    const defaultCurrencyInput = document.createElement('input'); defaultCurrencyInput.id='settingDefaultCurrency';
    defaultCurrencyInput.placeholder = 'é è¨­å¤–å¹£å¹£åˆ¥ (å¦‚: USD)';
    defaultCurrencyInput.value = state.settings.defaultCurrency;
    defaultCurrencyInput.onchange = async () => {
      state.settings.defaultCurrency = defaultCurrencyInput.value.toUpperCase().trim();
      log('ä¿®æ”¹è¨­å®š', 'ç³»çµ±', 'defaultCurrency', defaultCurrencyInput.value);
      incrementDataVersion();
      await saveAppState(); render(); // Rerender to update 'new slip/decl' forms
    };

    const note = document.createElement('div'); note.className='hint';
    note.textContent = 'ä¸»é¡Œè‡ªå‹•èª¿æ•´æ–‡å­—é¡è‰²ï¼›åŒ¯ç‡æ¨¡å¼ä¾æ‚¨å…¬å¸ç¿’æ…£èª¿æ•´ã€‚';

    s.appendChild(wrapField('åŒ¯ç‡è§£è®€', mode));
    s.appendChild(wrapField('é è¨­å¤–å¹£å¹£åˆ¥', defaultCurrencyInput));
    s.appendChild(note);

    const d = document.createElement('div'); d.className='card'; d.innerHTML='<h2>è³‡æ–™å‚™ä»½</h2>';
    const ta = document.createElement('textarea'); ta.id='dataBackupTextarea'; ta.value = JSON.stringify(state, null, 2);
    const row = document.createElement('div'); row.className='right';
    row.appendChild(button('é‡æ–°è¼‰å…¥é è¦½','ghost',async ()=>{ ta.value = JSON.stringify(state,null,2); }));
    row.appendChild(button('å¾æ–‡å­—åŒ¯å…¥','warn',debounce(async ()=>{ try{ const obj=JSON.parse(ta.value); Object.assign(state,obj); log('åŒ¯å…¥','è³‡æ–™','JSON',''); incrementDataVersion(); await saveAppState(); render(); }catch(e){ alert('JSON æ ¼å¼éŒ¯èª¤'); } }, 300)));
    row.appendChild(button('æ¸…ç©ºæ‰€æœ‰è³‡æ–™','danger',async ()=>{ if(confirm('æ­¤å‹•ä½œç„¡æ³•å¾©åŸï¼Œç¢ºå®šï¼Ÿ')){ await localforage.removeItem(storeKey); location.reload(); } }));

    d.appendChild(ta); d.appendChild(row);

    box.appendChild(s); box.appendChild(d);

    const updatePanel = () => {
        ta.value = JSON.stringify(state, null, 2);
    };

    return createPanel('data', (el) => {
        el.appendChild(box);
    }, updatePanel);
  }

  // Map of panel IDs to their creation functions
  const panelCreators = {
    slip: createPanelSlip,
    decl: createPanelDecl,
    fx: createPanelFx,
    audit: createPanelAudit,
    data: createPanelData,
  };

  // ------------------ Render Root ------------------
  async function render(forceTab = null){
    const targetTab = forceTab || activeTab;

    // Update global vendor datalists
    const globalVendorsList = document.getElementById('global-vendor-list');
    if(globalVendorsList){ globalVendorsList.innerHTML = allVendors().map(v=>`<option value="${v}"></option>`).join(''); }

    const allVendorsDatalist = document.getElementById('all-vendor-list');
    if(allVendorsDatalist){ allVendorsDatalist.innerHTML = allVendors().map(v=>`<option value="${v}"></option>`).join(''); }
    
    const slipVendorsDatalist = document.getElementById('slip-vendor-list');
    if(slipVendorsDatalist){ slipVendorsDatalist.innerHTML = slipVendors().map(v=>`<option value="${v}"></option>`).join(''); }

    // quickbar vendor list + default
    const gv = document.getElementById('globalVendor'); if(gv){
      const savedGV = localStorage.getItem(GLOBAL_VENDOR_KEY)||''; if(gv.value!==savedGV) gv.value=savedGV;
      gv.oninput = debounce(()=>{ localStorage.setItem(GLOBAL_VENDOR_KEY, gv.value.trim()); render(); }, 300);
    }

    // Set filters to global vendor
    const slipFilterVendor = document.getElementById('slipFilterVendor');
    if (slipFilterVendor) { slipFilterVendor.value = localStorage.getItem(GLOBAL_VENDOR_KEY) || ''; }
    const declFilterVendor = document.getElementById('declFilterVendor');
    if (declFilterVendor) { declFilterVendor.value = localStorage.getItem(GLOBAL_VENDOR_KEY) || ''; }
    const fxFilterVendor = document.getElementById('fxFilterVendor');
    if (fxFilterVendor) { fxFilterVendor.value = localStorage.getItem(GLOBAL_VENDOR_KEY) || ''; }


    renderTabs();

    if (!currentPanelInstance || currentPanelInstance.element.id !== `panel-${targetTab}`) {
      // Clear all existing panels with a fade out effect
      Array.from(elPanels.children).forEach(child => {
          child.classList.remove('is-active');
          setTimeout(() => child.remove(), 300); // Remove after transition
      });

      // Create new panel
      const newPanel = panelCreators[targetTab]();
      elPanels.appendChild(newPanel.element);
      currentPanelInstance = newPanel;

      // Force a reflow for transition to work
      void newPanel.element.offsetWidth;
      newPanel.element.classList.add('is-active');
      newPanel.update(); // Initial update for the new panel
    } else {
      // Update existing panel
      currentPanelInstance.update();
    }
  }

  // boot
  (async () => {
    const loaded = await loadAppState();
    if (loaded) {
      Object.assign(state, loaded);
    }
    // Ensure dataVersion is initialized for old states without it
    if (typeof state._dataVersion === 'undefined') {
        state._dataVersion = 0;
    }
    await render();
  })();
})();
</script>
</body>
</html>