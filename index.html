<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½é›¢ç·šæª”æ¡ˆæ•´ç†å·¥å…·</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif; background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%); min-height: 100vh; color: #e0e0e0; }
        .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
        h1 { text-align: center; padding: 20px; background: linear-gradient(90deg, #00d2ff, #3a7bd5, #f093fb); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-size: 2.2rem; text-shadow: 0 0 30px rgba(102, 126, 234, 0.3); }
        .subtitle { text-align: center; color: #888; margin-bottom: 20px; font-size: 14px; }
        
        .toolbar { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 20px; align-items: center; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); }
        .btn { padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s; display: inline-flex; align-items: center; gap: 8px; font-size: 13px; }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-success { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; }
        .btn-warning { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; }
        .btn-info { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: #1a1a2e; }
        .btn-ai { background: linear-gradient(135deg, #f5af19 0%, #f12711 100%); color: white; animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(245, 175, 25, 0.4); } 50% { box-shadow: 0 0 0 10px rgba(245, 175, 25, 0); } }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0,0,0,0.3); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        input[type="file"] { display: none; }
        
        .search-box { flex: 1; min-width: 200px; padding: 10px 15px; border: 2px solid #3a3a5a; border-radius: 8px; background: #1a1a2e; color: #e0e0e0; font-size: 14px; }
        .search-box:focus { outline: none; border-color: #667eea; box-shadow: 0 0 10px rgba(102, 126, 234, 0.3); }
        
        .panels { display: grid; grid-template-columns: 1fr 380px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .panel h2 { font-size: 1.1rem; margin-bottom: 15px; color: #a0a0ff; border-bottom: 1px solid #3a3a5a; padding-bottom: 10px; display: flex; align-items: center; gap: 10px; }
        
        .file-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .file-table th, .file-table td { padding: 10px; text-align: left; border-bottom: 1px solid #2a2a4a; }
        .file-table th { background: rgba(102, 126, 234, 0.2); position: sticky; top: 0; z-index: 10; }
        .file-table tr:hover { background: rgba(102, 126, 234, 0.1); }
        .file-table input { width: 100%; padding: 6px 8px; border: 1px solid #3a3a5a; border-radius: 4px; background: #1a1a2e; color: #e0e0e0; font-size: 12px; }
        .file-table input:focus { outline: none; border-color: #667eea; }
        .table-container { max-height: 550px; overflow-y: auto; }
        
        .tag { display: inline-block; padding: 3px 10px; border-radius: 12px; font-size: 11px; margin: 2px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
        .tag.tag-auto { background: linear-gradient(135deg, #f5af19, #f12711); }
        
        .rule-item { background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.05); }
        .rule-item input, .rule-item select { width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #3a3a5a; border-radius: 6px; background: #1a1a2e; color: #e0e0e0; font-size: 12px; }
        .rule-item label { font-size: 12px; color: #a0a0a0; display: block; margin-top: 8px; }
        .rule-item label:first-child { margin-top: 0; }
        .rule-actions { display: flex; gap: 5px; margin-top: 10px; }
        .rule-actions .btn { padding: 5px 10px; font-size: 11px; }
        
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; margin-bottom: 20px; }
        .stat-card { background: rgba(102, 126, 234, 0.15); padding: 15px; border-radius: 10px; text-align: center; border: 1px solid rgba(102, 126, 234, 0.3); transition: all 0.3s; }
        .stat-card:hover { transform: translateY(-3px); background: rgba(102, 126, 234, 0.25); }
        .stat-card .number { font-size: 1.8rem; font-weight: bold; background: linear-gradient(135deg, #667eea, #764ba2); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .stat-card .label { font-size: 12px; color: #a0a0a0; margin-top: 5px; }
        
        .progress-bar { height: 6px; background: #2a2a4a; border-radius: 3px; margin: 10px 0; overflow: hidden; }
        .progress-bar .fill { height: 100%; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb); transition: width 0.3s; }
        
        .checkbox-col { width: 30px; text-align: center !important; }
        .type-badge { padding: 4px 10px; border-radius: 6px; font-size: 11px; font-weight: bold; text-transform: uppercase; }
        .type-pdf { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        .type-docx { background: linear-gradient(135deg, #3498db, #2980b9); }
        .type-xlsx { background: linear-gradient(135deg, #27ae60, #1e8449); }
        .type-txt { background: linear-gradient(135deg, #9b59b6, #8e44ad); }
        .type-html { background: linear-gradient(135deg, #f39c12, #d68910); }
        
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 1000; align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-content { background: linear-gradient(135deg, #1a1a2e, #16213e); padding: 30px; border-radius: 16px; max-width: 700px; width: 90%; max-height: 80vh; overflow-y: auto; border: 1px solid rgba(255,255,255,0.1); }
        .modal-content h3 { margin-bottom: 20px; color: #667eea; }
        .modal-content pre { background: #0a0a1a; padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 12px; white-space: pre-wrap; word-break: break-all; max-height: 400px; overflow-y: auto; }
        .close-btn { float: right; cursor: pointer; font-size: 28px; color: #a0a0a0; line-height: 1; }
        .close-btn:hover { color: #fff; }
        
        .loading { display: inline-block; width: 20px; height: 20px; border: 2px solid #667eea; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .preview-text { max-height: 60px; overflow: hidden; font-size: 11px; color: #666; cursor: pointer; transition: color 0.3s; line-height: 1.4; }
        .preview-text:hover { color: #aaa; }
        
        .empty-state { text-align: center; padding: 60px 20px; color: #555; }
        .empty-state svg { width: 100px; height: 100px; margin-bottom: 20px; opacity: 0.3; }
        .empty-state p { margin-top: 10px; font-size: 14px; }
        
        .smart-section { background: linear-gradient(135deg, rgba(245, 175, 25, 0.1), rgba(241, 39, 17, 0.1)); border: 1px solid rgba(245, 175, 25, 0.3); border-radius: 10px; padding: 15px; margin-bottom: 15px; }
        .smart-section h3 { color: #f5af19; font-size: 14px; margin-bottom: 10px; display: flex; align-items: center; gap: 8px; }
        .smart-options { display: flex; flex-wrap: wrap; gap: 8px; }
        .smart-options label { display: flex; align-items: center; gap: 5px; font-size: 12px; cursor: pointer; padding: 5px 10px; background: rgba(0,0,0,0.2); border-radius: 6px; transition: all 0.3s; }
        .smart-options label:hover { background: rgba(245, 175, 25, 0.2); }
        .smart-options input[type="checkbox"] { accent-color: #f5af19; }
        
        .ai-badge { background: linear-gradient(135deg, #f5af19, #f12711); color: white; padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: bold; }
        
        .filename-preview { font-size: 11px; color: #888; margin-top: 3px; word-break: break-all; }
        
        /* å‰¯æª”åç¯©é¸æ¨£å¼ */
        .ext-filter-section { background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 242, 254, 0.1)); border: 1px solid rgba(79, 172, 254, 0.3); border-radius: 12px; padding: 15px; margin-bottom: 20px; }
        .ext-filter-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; flex-wrap: wrap; gap: 10px; }
        .ext-filter-header h3 { color: #4facfe; font-size: 14px; margin: 0; }
        .ext-filter-actions { display: flex; gap: 8px; }
        .btn-sm { padding: 6px 12px; font-size: 11px; }
        .ext-filter-list { display: flex; flex-wrap: wrap; gap: 8px; }
        .ext-filter-item { display: flex; align-items: center; gap: 8px; padding: 8px 14px; background: rgba(0,0,0,0.3); border-radius: 8px; cursor: pointer; transition: all 0.3s; border: 2px solid transparent; user-select: none; }
        .ext-filter-item:hover { background: rgba(79, 172, 254, 0.2); }
        .ext-filter-item.selected { border-color: #4facfe; background: rgba(79, 172, 254, 0.15); }
        .ext-filter-item input[type="checkbox"] { accent-color: #4facfe; width: 16px; height: 16px; cursor: pointer; }
        .ext-filter-item .ext-name { font-weight: 600; text-transform: uppercase; font-size: 12px; }
        .ext-filter-item .ext-count { background: rgba(255,255,255,0.1); padding: 2px 8px; border-radius: 10px; font-size: 11px; color: #aaa; }
        .ext-filter-item .ext-size { font-size: 10px; color: #888; }
        .ext-filter-summary { margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 12px; color: #aaa; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; }
        .ext-priority-hint { font-size: 11px; color: #f5af19; }
        
        @media (max-width: 1200px) { .panels { grid-template-columns: 1fr; } }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1a1a2e; }
        ::-webkit-scrollbar-thumb { background: #3a3a5a; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #4a4a6a; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§  æ™ºèƒ½é›¢ç·šæª”æ¡ˆæ•´ç†å·¥å…·</h1>
        <p class="subtitle">æ”¯æ´ PDF / Word / Excel / TXT / HTML è‡ªå‹•è§£æã€æ™ºèƒ½æ‰“æ¨™ã€æ‰¹æ¬¡é‡å‘½å</p>
        
        <div class="stats">
            <div class="stat-card"><div class="number" id="totalFiles">0</div><div class="label">ç¸½æª”æ¡ˆæ•¸</div></div>
            <div class="stat-card"><div class="number" id="pdfCount">0</div><div class="label">PDF</div></div>
            <div class="stat-card"><div class="number" id="docxCount">0</div><div class="label">Word</div></div>
            <div class="stat-card"><div class="number" id="xlsxCount">0</div><div class="label">Excel</div></div>
            <div class="stat-card"><div class="number" id="txtCount">0</div><div class="label">TXT/HTML</div></div>
            <div class="stat-card"><div class="number" id="taggedCount">0</div><div class="label">å·²æ¨™è¨˜</div></div>
            <div class="stat-card"><div class="number" id="renamedCount">0</div><div class="label">å·²é‡å‘½å</div></div>
        </div>

        <div class="toolbar">
            <label class="btn btn-primary">
                ğŸ“‚ é¸æ“‡è³‡æ–™å¤¾
                <input type="file" id="folderInput" webkitdirectory directory multiple>
            </label>
            <input type="text" class="search-box" id="searchBox" placeholder="ğŸ” æœå°‹æª”åã€å…§å®¹ã€æ¨™ç±¤...">
            <button class="btn btn-ai" id="smartAnalyzeBtn" disabled>ğŸ§  æ™ºèƒ½åˆ†æ</button>
            <button class="btn btn-success" id="applyRulesBtn" disabled>ğŸ·ï¸ å¥—ç”¨è¦å‰‡</button>
            <button class="btn btn-info" id="selectAllBtn">â˜‘ï¸ å…¨é¸</button>
            <button class="btn btn-warning" id="exportBatBtn" disabled>ğŸ“¤ åŒ¯å‡º BAT</button>
            <button class="btn btn-info" id="previewBatBtn" disabled>ğŸ‘ï¸ é è¦½</button>
        </div>

        <div class="progress-bar"><div class="fill" id="progressFill" style="width: 0%"></div></div>
        <div id="statusText" style="font-size: 12px; color: #888; margin-bottom: 15px; min-height: 18px;"></div>

        <!-- å‰¯æª”åç¯©é¸å€åŸŸ -->
        <div id="extFilterSection" class="ext-filter-section" style="display:none;">
            <div class="ext-filter-header">
                <h3>ğŸ“ å‰¯æª”åç¯©é¸</h3>
                <div class="ext-filter-actions">
                    <button class="btn btn-info btn-sm" id="extSelectAll">å…¨é¸</button>
                    <button class="btn btn-warning btn-sm" id="extDeselectAll">å–æ¶ˆå…¨é¸</button>
                    <button class="btn btn-success btn-sm" id="extApplyFilter">âœ“ å¥—ç”¨ç¯©é¸</button>
                </div>
            </div>
            <div class="ext-filter-list" id="extFilterList"></div>
            <div class="ext-filter-summary" id="extFilterSummary"></div>
        </div>

        <div class="panels">
            <div class="panel">
                <h2>ğŸ“„ æª”æ¡ˆæ¸…å–® <span style="font-size:12px;color:#888;font-weight:normal;">(<span id="fileCountDisplay">0</span> å€‹)</span></h2>
                <div class="table-container">
                    <table class="file-table">
                        <thead>
                            <tr>
                                <th class="checkbox-col"><input type="checkbox" id="checkAll"></th>
                                <th style="width:70px">é¡å‹</th>
                                <th style="width:200px">åŸå§‹æª”å</th>
                                <th style="width:250px">å»ºè­°æª”å</th>
                                <th style="width:150px">ç›®æ¨™è³‡æ–™å¤¾</th>
                                <th>æ¨™ç±¤</th>
                            </tr>
                        </thead>
                        <tbody id="fileTableBody">
                            <tr><td colspan="6" class="empty-state">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                                    <path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
                                </svg>
                                <div>è«‹é¸æ“‡è³‡æ–™å¤¾ä»¥é–‹å§‹åˆ†ææª”æ¡ˆ</div>
                                <p>æ”¯æ´ PDFã€Wordã€Excelã€TXTã€HTML æ ¼å¼</p>
                            </td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="panel">
                <h2>ğŸ§  æ™ºèƒ½åˆ†æè¨­å®š</h2>
                <div class="smart-section">
                    <h3>âœ¨ è‡ªå‹•åµæ¸¬é …ç›® <button class="btn btn-success" id="addDetectItemBtn" style="padding:3px 10px;font-size:11px;margin-left:auto;">â• æ–°å¢</button></h3>
                    <div class="smart-options" id="builtinDetectOptions">
                        <label><input type="checkbox" id="detectDate" checked> æ—¥æœŸ</label>
                        <label><input type="checkbox" id="detectCompany" checked> å…¬å¸åç¨±</label>
                    </div>
                    <div class="smart-options" id="documentTypeOptions" style="margin-top:8px;">
                        <label><input type="checkbox" data-type="invoice" checked> ç™¼ç¥¨/æ”¶æ“š</label>
                        <label><input type="checkbox" data-type="contract" checked> åˆç´„</label>
                        <label><input type="checkbox" data-type="report" checked> å ±å‘Š</label>
                        <label><input type="checkbox" data-type="meeting" checked> æœƒè­°</label>
                        <label><input type="checkbox" data-type="resume" checked> å±¥æ­·</label>
                        <label><input type="checkbox" data-type="quotation" checked> å ±åƒ¹å–®</label>
                        <label><input type="checkbox" data-type="financial" checked> è²¡å‹™</label>
                        <label><input type="checkbox" data-type="legal" checked> æ³•å¾‹</label>
                    </div>
                    <div id="customDetectItems" style="margin-top:10px;"></div>
                </div>

                <h2 style="margin-top:15px;">âš™ï¸ è‡ªè¨‚è¦å‰‡</h2>
                <div id="rulesContainer">
                    <div class="rule-item">
                        <label>é—œéµå­—ï¼ˆé€—è™Ÿåˆ†éš”ï¼‰</label>
                        <input type="text" class="rule-keyword" placeholder="ä¾‹å¦‚ï¼šåˆç´„, contract, å”è­°">
                        <label>æ¨™ç±¤</label>
                        <input type="text" class="rule-tag" placeholder="ä¾‹å¦‚ï¼šåˆç´„æ–‡ä»¶">
                        <label>ç›®æ¨™è³‡æ–™å¤¾</label>
                        <input type="text" class="rule-folder" placeholder="ä¾‹å¦‚ï¼š01_åˆç´„">
                        <label>æª”åæ ¼å¼</label>
                        <input type="text" class="rule-format" placeholder="ä¾‹å¦‚ï¼š[åˆç´„] {date}_{company}_{original}">
                        <div style="font-size:10px;color:#666;margin-top:5px;">å¯ç”¨è®Šæ•¸: {date}, {company}, {original}, {type}</div>
                        <div class="rule-actions">
                            <button class="btn btn-warning remove-rule">âœ– åˆªé™¤</button>
                        </div>
                    </div>
                </div>
                <button class="btn btn-success" id="addRuleBtn" style="width:100%; margin-top:10px;">â• æ–°å¢è¦å‰‡</button>
                
                <h2 style="margin-top: 20px;">ğŸ’¾ è¦å‰‡ç®¡ç†</h2>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="btn btn-info" id="saveRulesBtn" style="flex:1;">ğŸ’¾ å„²å­˜</button>
                    <button class="btn btn-primary" id="loadRulesBtn" style="flex:1;">ğŸ“‚ è¼‰å…¥</button>
                    <button class="btn btn-warning" id="clearRulesBtn" style="flex:1;">ğŸ—‘ï¸ æ¸…é™¤</button>
                </div>
                <input type="file" id="loadRulesInput" accept=".json" style="display:none">
            </div>
        </div>
    </div>

    <div class="modal" id="batPreviewModal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeBatPreview()">&times;</span>
            <h3>ğŸ“„ BAT æ‰¹æ¬¡æª”é è¦½</h3>
            <pre id="batPreviewContent"></pre>
            <div style="display:flex;gap:10px;margin-top:15px;">
                <button class="btn btn-success" style="flex:1;" onclick="downloadBat()">â¬‡ï¸ ä¸‹è¼‰ BAT æª”æ¡ˆ</button>
                <button class="btn btn-info" style="flex:1;" onclick="copyBat()">ğŸ“‹ è¤‡è£½å…§å®¹</button>
            </div>
        </div>
    </div>

    <div class="modal" id="contentModal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeContentModal()">&times;</span>
            <h3 id="contentModalTitle">ğŸ“„ æª”æ¡ˆå…§å®¹é è¦½</h3>
            <pre id="contentPreview"></pre>
        </div>
    </div>

    <div class="modal" id="addDetectModal">
        <div class="modal-content" style="max-width:500px;">
            <span class="close-btn" onclick="closeAddDetectModal()">&times;</span>
            <h3>âœ¨ æ–°å¢è‡ªè¨‚åµæ¸¬é …ç›®</h3>
            <div class="rule-item" style="margin-top:15px;">
                <label>é …ç›®åç¨± *</label>
                <input type="text" id="newDetectName" placeholder="ä¾‹å¦‚ï¼šè¨‚å–®">
                <label>é—œéµå­—ï¼ˆé€—è™Ÿåˆ†éš”ï¼‰*</label>
                <input type="text" id="newDetectKeywords" placeholder="ä¾‹å¦‚ï¼šè¨‚å–®, order, æ¡è³¼å–®, PO">
                <label>æ¨™ç±¤</label>
                <input type="text" id="newDetectTag" placeholder="ä¾‹å¦‚ï¼šè¨‚å–®">
                <label>ç›®æ¨™è³‡æ–™å¤¾</label>
                <input type="text" id="newDetectFolder" placeholder="ä¾‹å¦‚ï¼š09_è¨‚å–®">
            </div>
            <div style="display:flex;gap:10px;margin-top:20px;">
                <button class="btn btn-success" style="flex:1;" onclick="saveCustomDetectItem()">âœ… æ–°å¢</button>
                <button class="btn btn-warning" style="flex:1;" onclick="closeAddDetectModal()">âŒ å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <script>
    // ============ æ™ºèƒ½æ–‡å­—æå–å™¨ ============
    const TextExtractor = {
        // å¾äºŒé€²ä½è³‡æ–™ä¸­æå–å¯è®€æ–‡å­—
        extractReadableText(bytes) {
            const chunks = [];
            let currentChunk = '';
            
            for (let i = 0; i < bytes.length; i++) {
                const byte = bytes[i];
                // å¯åˆ—å° ASCII å­—å…ƒ
                if (byte >= 32 && byte <= 126) {
                    currentChunk += String.fromCharCode(byte);
                }
                // ä¸­æ–‡ UTF-8 (3 bytes: 0xE4-0xE9 é–‹é ­)
                else if (byte >= 0xE4 && byte <= 0xE9 && i + 2 < bytes.length) {
                    try {
                        const char = new TextDecoder('utf-8').decode(bytes.slice(i, i + 3));
                        if (char && !char.includes('ï¿½')) {
                            currentChunk += char;
                            i += 2;
                        }
                    } catch (e) {}
                }
                // ç©ºç™½/æ›è¡Œ
                else if (byte === 10 || byte === 13 || byte === 9) {
                    if (currentChunk.length > 0) {
                        currentChunk += ' ';
                    }
                }
                // å…¶ä»–å­—å…ƒ - æª¢æŸ¥æ˜¯å¦éœ€è¦æ–·é–‹
                else if (currentChunk.length > 2) {
                    chunks.push(currentChunk.trim());
                    currentChunk = '';
                }
            }
            
            if (currentChunk.length > 2) {
                chunks.push(currentChunk.trim());
            }
            
            // éæ¿¾ä¸¦é€£æ¥æœ‰æ„ç¾©çš„æ–‡å­—ç‰‡æ®µ
            return chunks
                .filter(c => c.length > 3 && !/^[^a-zA-Z\u4e00-\u9fff]*$/.test(c))
                .join(' ')
                .replace(/\s+/g, ' ')
                .trim();
        }
    };

    // ============ PDF è§£æå™¨ ============
    const PDFParser = {
        async parse(arrayBuffer) {
            try {
                const bytes = new Uint8Array(arrayBuffer);
                let extractedText = '';
                
                // æ–¹æ³•1: å°‹æ‰¾æ–‡å­—ç‰©ä»¶
                const textObjects = this.findTextObjects(bytes);
                if (textObjects.length > 0) {
                    extractedText = textObjects.join(' ');
                }
                
                // æ–¹æ³•2: è§£å£“ç¸®æµä¸¦æå–
                if (extractedText.length < 50) {
                    const streamTexts = await this.extractFromStreams(bytes);
                    if (streamTexts.length > extractedText.length) {
                        extractedText = streamTexts;
                    }
                }
                
                // æ–¹æ³•3: ç›´æ¥æå–å¯è®€æ–‡å­—
                if (extractedText.length < 50) {
                    extractedText = TextExtractor.extractReadableText(bytes);
                }
                
                // æ¸…ç†æ–‡å­—
                extractedText = this.cleanText(extractedText);
                
                return extractedText || '[PDF å…§å®¹ç„¡æ³•æå– - å¯èƒ½æ˜¯æƒææª”æˆ–åŠ å¯†æª”æ¡ˆ]';
            } catch (e) {
                console.error('PDF parse error:', e);
                return '[PDF è§£æéŒ¯èª¤]';
            }
        },
        
        findTextObjects(bytes) {
            const texts = [];
            const str = new TextDecoder('latin1').decode(bytes);
            
            // å°‹æ‰¾ BT...ET æ–‡å­—å€å¡Š
            const btEtPattern = /BT\s*([\s\S]*?)\s*ET/g;
            let match;
            
            while ((match = btEtPattern.exec(str)) !== null) {
                const block = match[1];
                
                // æå– Tj æ“ä½œç¬¦çš„æ–‡å­—
                const tjMatches = block.matchAll(/\(([^)]*)\)\s*Tj/g);
                for (const tj of tjMatches) {
                    const decoded = this.decodeString(tj[1]);
                    if (decoded) texts.push(decoded);
                }
                
                // æå– TJ é™£åˆ—ä¸­çš„æ–‡å­—
                const tjArrayMatches = block.matchAll(/\[((?:[^[\]]*|\([^)]*\))*)\]\s*TJ/gi);
                for (const tja of tjArrayMatches) {
                    const innerMatches = tja[1].matchAll(/\(([^)]*)\)/g);
                    for (const inner of innerMatches) {
                        const decoded = this.decodeString(inner[1]);
                        if (decoded) texts.push(decoded);
                    }
                }
                
                // æå– ' å’Œ " æ“ä½œç¬¦
                const quoteMatches = block.matchAll(/\(([^)]*)\)\s*['"]/g);
                for (const qm of quoteMatches) {
                    const decoded = this.decodeString(qm[1]);
                    if (decoded) texts.push(decoded);
                }
            }
            
            return texts;
        },
        
        async extractFromStreams(bytes) {
            const str = new TextDecoder('latin1').decode(bytes);
            const texts = [];
            
            // å°‹æ‰¾ stream...endstream
            const streamPattern = /stream\r?\n([\s\S]*?)\r?\nendstream/g;
            let match;
            
            while ((match = streamPattern.exec(str)) !== null) {
                const streamData = match[1];
                const streamBytes = new Uint8Array(streamData.length);
                for (let i = 0; i < streamData.length; i++) {
                    streamBytes[i] = streamData.charCodeAt(i);
                }
                
                // å˜—è©¦è§£å£“ç¸® (FlateDecode)
                try {
                    if (typeof DecompressionStream !== 'undefined') {
                        const decompressed = await this.inflate(streamBytes);
                        if (decompressed) {
                            const text = this.extractTextFromDecompressed(decompressed);
                            if (text) texts.push(text);
                        }
                    }
                } catch (e) {
                    // è§£å£“ç¸®å¤±æ•—,å˜—è©¦ç›´æ¥æå–
                    const directText = TextExtractor.extractReadableText(streamBytes);
                    if (directText.length > 10) texts.push(directText);
                }
            }
            
            return texts.join(' ');
        },
        
        async inflate(data) {
            try {
                // æª¢æŸ¥ zlib header (78 01, 78 5E, 78 9C, 78 DA)
                let streamData = data;
                if (data[0] === 0x78) {
                    streamData = data.slice(2); // è·³é zlib header
                }
                
                const ds = new DecompressionStream('deflate-raw');
                const writer = ds.writable.getWriter();
                writer.write(streamData);
                writer.close();
                
                const reader = ds.readable.getReader();
                const chunks = [];
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    chunks.push(value);
                }
                
                const totalLength = chunks.reduce((a, c) => a + c.length, 0);
                const result = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of chunks) {
                    result.set(chunk, offset);
                    offset += chunk.length;
                }
                
                return result;
            } catch (e) {
                return null;
            }
        },
        
        extractTextFromDecompressed(bytes) {
            const str = new TextDecoder('latin1').decode(bytes);
            const texts = [];
            
            // å¾è§£å£“ç¸®çš„å…§å®¹ä¸­æå–æ–‡å­—
            const tjMatches = str.matchAll(/\(([^)]*)\)\s*Tj/g);
            for (const tj of tjMatches) {
                const decoded = this.decodeString(tj[1]);
                if (decoded) texts.push(decoded);
            }
            
            const tjArrayMatches = str.matchAll(/\[((?:[^[\]]*|\([^)]*\))*)\]\s*TJ/gi);
            for (const tja of tjArrayMatches) {
                const innerMatches = tja[1].matchAll(/\(([^)]*)\)/g);
                for (const inner of innerMatches) {
                    const decoded = this.decodeString(inner[1]);
                    if (decoded) texts.push(decoded);
                }
            }
            
            if (texts.length === 0) {
                // å‚™ç”¨: æå–å¯è®€å­—å…ƒ
                return TextExtractor.extractReadableText(bytes);
            }
            
            return texts.join(' ');
        },
        
        decodeString(str) {
            if (!str) return '';
            
            // è™•ç†è·³è„«å­—å…ƒ
            let result = str
                .replace(/\\n/g, '\n')
                .replace(/\\r/g, '')
                .replace(/\\t/g, ' ')
                .replace(/\\\(/g, '(')
                .replace(/\\\)/g, ')')
                .replace(/\\\\/g, '\\');
            
            // è™•ç†å…«é€²ä½è·³è„« \nnn
            result = result.replace(/\\([0-7]{1,3})/g, (match, oct) => {
                return String.fromCharCode(parseInt(oct, 8));
            });
            
            // éæ¿¾æ§åˆ¶å­—å…ƒ
            result = result.replace(/[\x00-\x1f]/g, ' ');
            
            return result.trim();
        },
        
        cleanText(text) {
            if (!text) return '';
            
            return text
                .replace(/[\x00-\x1f]/g, ' ')  // ç§»é™¤æ§åˆ¶å­—å…ƒ
                .replace(/[^\u0020-\u007e\u00a0-\u00ff\u4e00-\u9fff\u3400-\u4dbf\uf000-\ufaff\n]/g, ' ')  // ä¿ç•™å¸¸ç”¨å­—å…ƒ
                .replace(/\s+/g, ' ')  // åˆä½µç©ºç™½
                .trim()
                .substring(0, 8000);  // é™åˆ¶é•·åº¦
        }
    };

    // ============ DOCX è§£æå™¨ ============
    const DOCXParser = {
        async parse(arrayBuffer) {
            try {
                const zip = await this.unzip(new Uint8Array(arrayBuffer));
                
                // å„ªå…ˆè®€å– document.xml
                let documentContent = zip['word/document.xml'];
                if (!documentContent) {
                    // å˜—è©¦å…¶ä»–å¯èƒ½çš„è·¯å¾‘
                    for (const key of Object.keys(zip)) {
                        if (key.includes('document') && key.endsWith('.xml')) {
                            documentContent = zip[key];
                            break;
                        }
                    }
                }
                
                if (!documentContent) {
                    return '[ç„¡æ³•æ‰¾åˆ° Word æ–‡ä»¶å…§å®¹]';
                }
                
                const decoder = new TextDecoder('utf-8');
                const xmlContent = decoder.decode(documentContent);
                
                // æå–æ‰€æœ‰æ–‡å­—ç¯€é»
                let text = '';
                
                // ç§»é™¤ XML æ¨™ç±¤ä½†ä¿ç•™æ®µè½çµæ§‹
                text = xmlContent
                    .replace(/<w:p[^>]*>/g, '\n')  // æ®µè½æ›è¡Œ
                    .replace(/<w:br[^>]*>/g, '\n')  // æ›è¡Œç¬¦
                    .replace(/<w:tab[^>]*>/g, '\t')  // Tab
                    .replace(/<w:t[^>]*>([^<]*)<\/w:t>/g, '$1')  // æå–æ–‡å­—
                    .replace(/<[^>]+>/g, '')  // ç§»é™¤å…¶ä»–æ¨™ç±¤
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>')
                    .replace(/&amp;/g, '&')
                    .replace(/&quot;/g, '"')
                    .replace(/&apos;/g, "'")
                    .replace(/&#(\d+);/g, (m, code) => String.fromCharCode(code))
                    .replace(/\n\s*\n/g, '\n')  // ç§»é™¤å¤šé¤˜ç©ºè¡Œ
                    .replace(/\s+/g, ' ')
                    .trim();
                
                return text.substring(0, 8000) || '[Word æ–‡ä»¶ç‚ºç©º]';
            } catch (e) {
                console.error('DOCX parse error:', e);
                return '[DOCX è§£æéŒ¯èª¤: ' + e.message + ']';
            }
        },
        
        async unzip(bytes) {
            const files = {};
            let pos = 0;
            
            while (pos < bytes.length - 4) {
                // æœ¬åœ°æª”æ¡ˆé ­æ¨™è¨˜ 0x04034B50
                if (bytes[pos] === 0x50 && bytes[pos+1] === 0x4B && 
                    bytes[pos+2] === 0x03 && bytes[pos+3] === 0x04) {
                    
                    const view = new DataView(bytes.buffer, bytes.byteOffset + pos);
                    const compressionMethod = view.getUint16(8, true);
                    const compressedSize = view.getUint32(18, true);
                    const fileNameLength = view.getUint16(26, true);
                    const extraLength = view.getUint16(28, true);
                    
                    const fileName = new TextDecoder().decode(
                        bytes.slice(pos + 30, pos + 30 + fileNameLength)
                    );
                    
                    const dataStart = pos + 30 + fileNameLength + extraLength;
                    const dataEnd = dataStart + compressedSize;
                    
                    if (dataEnd <= bytes.length) {
                        const fileData = bytes.slice(dataStart, dataEnd);
                        
                        if (compressionMethod === 0) {
                            // ç„¡å£“ç¸®
                            files[fileName] = fileData;
                        } else if (compressionMethod === 8) {
                            // Deflate å£“ç¸®
                            try {
                                const decompressed = await this.inflateRaw(fileData);
                                files[fileName] = decompressed;
                            } catch (e) {
                                files[fileName] = fileData;
                            }
                        }
                        
                        pos = dataEnd;
                    } else {
                        break;
                    }
                } else {
                    pos++;
                }
            }
            
            return files;
        },
        
        async inflateRaw(data) {
            const ds = new DecompressionStream('deflate-raw');
            const writer = ds.writable.getWriter();
            writer.write(data);
            writer.close();
            
            const reader = ds.readable.getReader();
            const chunks = [];
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                chunks.push(value);
            }
            
            const totalLength = chunks.reduce((a, c) => a + c.length, 0);
            const result = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of chunks) {
                result.set(chunk, offset);
                offset += chunk.length;
            }
            
            return result;
        }
    };

    // ============ XLSX è§£æå™¨ ============
    const XLSXParser = {
        async parse(arrayBuffer) {
            try {
                const zip = await DOCXParser.unzip(new Uint8Array(arrayBuffer));
                let allText = [];
                
                // è®€å–å…±äº«å­—ä¸²
                const sharedStrings = [];
                const ssFile = zip['xl/sharedStrings.xml'];
                if (ssFile) {
                    const decoder = new TextDecoder('utf-8');
                    const ssXml = decoder.decode(ssFile);
                    
                    // æå– <t> æ¨™ç±¤ä¸­çš„æ–‡å­—
                    const tMatches = ssXml.matchAll(/<t[^>]*>([^<]*)<\/t>/g);
                    for (const m of tMatches) {
                        let text = m[1]
                            .replace(/&lt;/g, '<')
                            .replace(/&gt;/g, '>')
                            .replace(/&amp;/g, '&')
                            .replace(/&quot;/g, '"');
                        sharedStrings.push(text);
                    }
                }
                
                // è®€å–æ‰€æœ‰å·¥ä½œè¡¨
                for (const [name, content] of Object.entries(zip)) {
                    if (name.match(/xl\/worksheets\/sheet\d+\.xml/)) {
                        const decoder = new TextDecoder('utf-8');
                        const sheetXml = decoder.decode(content);
                        
                        // æå–å„²å­˜æ ¼
                        const cellPattern = /<c[^>]*>([\s\S]*?)<\/c>/g;
                        let cellMatch;
                        
                        while ((cellMatch = cellPattern.exec(sheetXml)) !== null) {
                            const cellTag = cellMatch[0];
                            const cellContent = cellMatch[1];
                            
                            // å–å¾—å€¼
                            const valueMatch = cellContent.match(/<v>([^<]*)<\/v>/);
                            if (valueMatch) {
                                const value = valueMatch[1];
                                
                                // æª¢æŸ¥æ˜¯å¦æ˜¯å…±äº«å­—ä¸²
                                if (cellTag.includes('t="s"')) {
                                    const idx = parseInt(value);
                                    if (sharedStrings[idx]) {
                                        allText.push(sharedStrings[idx]);
                                    }
                                } else if (cellTag.includes('t="inlineStr"')) {
                                    // å…§è¯å­—ä¸²
                                    const tMatch = cellContent.match(/<t[^>]*>([^<]*)<\/t>/);
                                    if (tMatch) allText.push(tMatch[1]);
                                } else {
                                    allText.push(value);
                                }
                            }
                        }
                    }
                }
                
                const result = allText.join(' ').replace(/\s+/g, ' ').trim();
                return result.substring(0, 8000) || '[Excel å·¥ä½œè¡¨ç‚ºç©º]';
            } catch (e) {
                console.error('XLSX parse error:', e);
                return '[XLSX è§£æéŒ¯èª¤: ' + e.message + ']';
            }
        }
    };

    // ============ æ™ºèƒ½åˆ†æå¼•æ“ ============
    const SmartAnalyzer = {
        // æ—¥æœŸæ¨¡å¼
        datePatterns: [
            /(\d{4})[\/\-å¹´](\d{1,2})[\/\-æœˆ](\d{1,2})[æ—¥è™Ÿ]?/g,
            /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/g,
            /(\d{4})(\d{2})(\d{2})/g,
            /(æ°‘åœ‹)?(\d{2,3})å¹´(\d{1,2})æœˆ(\d{1,2})æ—¥/g
        ],
        
        // å…¬å¸åç¨±æ¨¡å¼
        companyPatterns: [
            /([^\s,ï¼Œã€‚]{2,15})(è‚¡ä»½æœ‰é™å…¬å¸|æœ‰é™å…¬å¸|å…¬å¸|ä¼æ¥­|é›†åœ˜|Corp\.?|Inc\.?|Ltd\.?|LLC)/gi,
            /([A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,3})\s+(Corporation|Company|Inc|Ltd)/gi
        ],
        
        // æ–‡ä»¶é¡å‹é—œéµå­—
        documentTypes: {
            invoice: {
                keywords: ['ç™¼ç¥¨', 'çµ±ä¸€ç™¼ç¥¨', 'invoice', 'æ”¶æ“š', 'receipt', 'é›»å­ç™¼ç¥¨', 'ä¸‰è¯å¼'],
                folder: '01_ç™¼ç¥¨æ”¶æ“š',
                tag: 'ç™¼ç¥¨'
            },
            contract: {
                keywords: ['åˆç´„', 'å¥‘ç´„', 'contract', 'agreement', 'å”è­°æ›¸', 'åˆåŒ', 'æœå‹™æ¢æ¬¾'],
                folder: '02_åˆç´„æ–‡ä»¶',
                tag: 'åˆç´„'
            },
            report: {
                keywords: ['å ±å‘Š', 'report', 'åˆ†æ', 'analysis', 'ç ”ç©¶', 'èª¿æŸ¥', 'è©•ä¼°', 'å ±è¡¨'],
                folder: '03_å ±å‘Šæ–‡ä»¶',
                tag: 'å ±å‘Š'
            },
            meeting: {
                keywords: ['æœƒè­°', 'meeting', 'è­°ç¨‹', 'agenda', 'ç´€éŒ„', 'minutes', 'è¨è«–'],
                folder: '04_æœƒè­°è³‡æ–™',
                tag: 'æœƒè­°'
            },
            resume: {
                keywords: ['å±¥æ­·', 'ç°¡æ­·', 'resume', 'cv', 'curriculum vitae', 'å€‹äººè³‡æ–™', 'å·¥ä½œç¶“æ­·'],
                folder: '05_å±¥æ­·è³‡æ–™',
                tag: 'å±¥æ­·'
            },
            quotation: {
                keywords: ['å ±åƒ¹', 'å ±åƒ¹å–®', 'quotation', 'quote', 'ä¼°åƒ¹', 'åƒ¹ç›®', 'proposal'],
                folder: '06_å ±åƒ¹å–®',
                tag: 'å ±åƒ¹'
            },
            financial: {
                keywords: ['è²¡å‹™', 'è²¡å ±', 'è³‡ç”¢è² å‚µ', 'æç›Š', 'ç¾é‡‘æµ', 'financial', 'balance sheet'],
                folder: '07_è²¡å‹™è³‡æ–™',
                tag: 'è²¡å‹™'
            },
            legal: {
                keywords: ['æ³•å¾‹', 'å¾‹å¸«', 'è¨´è¨Ÿ', 'åˆ¤æ±º', 'æ³•è¦', 'legal', 'law', 'æ¢ä¾‹'],
                folder: '08_æ³•å¾‹æ–‡ä»¶',
                tag: 'æ³•å¾‹'
            }
        },
        
        analyze(file) {
            const result = {
                dates: [],
                companies: [],
                documentType: null,
                tags: [],
                suggestedName: file.name,
                suggestedFolder: ''
            };
            
            const searchText = (file.name + ' ' + file.content).toLowerCase();
            const originalText = file.name + ' ' + file.content;
            
            // æå–æ—¥æœŸ
            if (document.getElementById('detectDate')?.checked) {
                for (const pattern of this.datePatterns) {
                    const matches = originalText.matchAll(new RegExp(pattern.source, pattern.flags));
                    for (const match of matches) {
                        let dateStr = this.normalizeDate(match);
                        if (dateStr && !result.dates.includes(dateStr)) {
                            result.dates.push(dateStr);
                        }
                    }
                }
            }
            
            // æå–å…¬å¸åç¨±
            if (document.getElementById('detectCompany')?.checked) {
                for (const pattern of this.companyPatterns) {
                    const matches = originalText.matchAll(new RegExp(pattern.source, pattern.flags));
                    for (const match of matches) {
                        let company = match[0].trim();
                        // éæ¿¾å¤ªçŸ­æˆ–å¤ªé•·çš„
                        if (company.length >= 4 && company.length <= 30) {
                            if (!result.companies.some(c => c.includes(company) || company.includes(c))) {
                                result.companies.push(company);
                            }
                        }
                    }
                }
            }
            
            // è­˜åˆ¥æ–‡ä»¶é¡å‹
            for (const [type, config] of Object.entries(this.documentTypes)) {
                const checkboxId = 'detect' + type.charAt(0).toUpperCase() + type.slice(1);
                const checkbox = document.getElementById(checkboxId);
                
                if (checkbox && !checkbox.checked) continue;
                
                const matched = config.keywords.some(kw => searchText.includes(kw.toLowerCase()));
                if (matched) {
                    if (!result.documentType) {
                        result.documentType = type;
                        result.suggestedFolder = config.folder;
                    }
                    if (!result.tags.includes(config.tag)) {
                        result.tags.push(config.tag);
                    }
                }
            }
            
            // ç”Ÿæˆå»ºè­°æª”å
            result.suggestedName = this.generateFileName(file, result);
            
            return result;
        },
        
        normalizeDate(match) {
            try {
                const str = match[0];
                let year, month, day;
                
                // æ°‘åœ‹å¹´
                if (str.includes('æ°‘åœ‹') || /^\d{2,3}å¹´/.test(str)) {
                    const m = str.match(/(\d{2,3})å¹´(\d{1,2})æœˆ(\d{1,2})/);
                    if (m) {
                        year = parseInt(m[1]) + (parseInt(m[1]) < 200 ? 1911 : 0);
                        month = m[2].padStart(2, '0');
                        day = m[3].padStart(2, '0');
                    }
                }
                // è¥¿å…ƒå¹´
                else if (match[1] && match[1].length === 4) {
                    year = match[1];
                    month = (match[2] || '01').padStart(2, '0');
                    day = (match[3] || '01').padStart(2, '0');
                }
                // å…¶ä»–æ ¼å¼
                else if (match[3] && match[3].length === 4) {
                    year = match[3];
                    month = (match[1] || '01').padStart(2, '0');
                    day = (match[2] || '01').padStart(2, '0');
                }
                // YYYYMMDD
                else if (/^\d{8}$/.test(str)) {
                    year = str.substring(0, 4);
                    month = str.substring(4, 6);
                    day = str.substring(6, 8);
                }
                
                if (year && parseInt(year) >= 1990 && parseInt(year) <= 2100) {
                    return `${year}${month}${day}`;
                }
            } catch (e) {}
            return null;
        },
        
        generateFileName(file, analysis) {
            const ext = '.' + file.name.split('.').pop();
            const baseName = file.name.replace(/\.[^.]+$/, '');
            
            let parts = [];
            
            // æ·»åŠ æ–‡ä»¶é¡å‹æ¨™ç±¤
            if (analysis.documentType) {
                const typeConfig = this.documentTypes[analysis.documentType];
                parts.push(`[${typeConfig.tag}]`);
            }
            
            // æ·»åŠ æ—¥æœŸ
            if (analysis.dates.length > 0) {
                parts.push(analysis.dates[0]);
            }
            
            // æ·»åŠ å…¬å¸åç¨±ï¼ˆç°¡åŒ–ï¼‰
            if (analysis.companies.length > 0) {
                let company = analysis.companies[0];
                // ç°¡åŒ–å…¬å¸åç¨±
                company = company.replace(/(è‚¡ä»½æœ‰é™å…¬å¸|æœ‰é™å…¬å¸)$/, '');
                if (company.length > 10) company = company.substring(0, 10);
                parts.push(company);
            }
            
            // å¦‚æœæ²’æœ‰æå–åˆ°ä»»ä½•è³‡è¨Šï¼Œä¿ç•™åŸæª”å
            if (parts.length === 0) {
                return file.name;
            }
            
            // æ·»åŠ åŸå§‹æª”åçš„ç°¡åŒ–ç‰ˆæœ¬
            let shortName = baseName
                .replace(/[\[\]ã€ã€‘\(\)ï¼ˆï¼‰]/g, '')
                .replace(/\s+/g, '_')
                .substring(0, 20);
            
            if (shortName && !parts.some(p => shortName.includes(p) || p.includes(shortName))) {
                parts.push(shortName);
            }
            
            return parts.join('_') + ext;
        }
    };

    // ============ ä¸»ç¨‹å¼ ============
    let files = [];
    let filteredFiles = [];
    let generatedBat = '';

    // DOM å…ƒç´ 
    const folderInput = document.getElementById('folderInput');
    const searchBox = document.getElementById('searchBox');
    const fileTableBody = document.getElementById('fileTableBody');
    const applyRulesBtn = document.getElementById('applyRulesBtn');
    const exportBatBtn = document.getElementById('exportBatBtn');
    const previewBatBtn = document.getElementById('previewBatBtn');
    const smartAnalyzeBtn = document.getElementById('smartAnalyzeBtn');
    const addRuleBtn = document.getElementById('addRuleBtn');
    const rulesContainer = document.getElementById('rulesContainer');
    const progressFill = document.getElementById('progressFill');
    const statusText = document.getElementById('statusText');
    const checkAll = document.getElementById('checkAll');

    // é¸æ“‡è³‡æ–™å¤¾
    folderInput.addEventListener('change', async (e) => {
        const fileList = Array.from(e.target.files);
        const supportedTypes = ['.pdf', '.docx', '.xlsx', '.xls', '.txt', '.html', '.htm', '.xml', '.csv'];
        
        files = fileList.filter(f => {
            const ext = '.' + f.name.split('.').pop().toLowerCase();
            return supportedTypes.includes(ext) && !f.name.startsWith('.');
        }).map(f => ({
            file: f,
            name: f.name,
            path: f.webkitRelativePath,
            type: f.name.split('.').pop().toLowerCase(),
            size: f.size,
            content: '',
            suggestedName: f.name,
            suggestedFolder: '',
            tags: [],
            selected: true,
            analyzed: false
        }));

        if (files.length === 0) {
            statusText.textContent = 'æœªæ‰¾åˆ°æ”¯æ´çš„æª”æ¡ˆæ ¼å¼';
            return;
        }

        updateStats();
        
        // è§£ææª”æ¡ˆå…§å®¹
        statusText.innerHTML = '<span class="loading"></span> æ­£åœ¨è§£ææª”æ¡ˆå…§å®¹...';
        
        for (let i = 0; i < files.length; i++) {
            const f = files[i];
            progressFill.style.width = ((i + 1) / files.length * 100) + '%';
            statusText.innerHTML = `<span class="loading"></span> è§£æä¸­: ${f.name} (${i + 1}/${files.length})`;
            
            try {
                const arrayBuffer = await f.file.arrayBuffer();
                
                switch (f.type) {
                    case 'pdf':
                        f.content = await PDFParser.parse(arrayBuffer);
                        break;
                    case 'docx':
                        f.content = await DOCXParser.parse(arrayBuffer);
                        break;
                    case 'xlsx':
                    case 'xls':
                        f.content = await XLSXParser.parse(arrayBuffer);
                        break;
                    case 'txt':
                    case 'html':
                    case 'htm':
                    case 'xml':
                    case 'csv':
                        // å˜—è©¦ä¸åŒç·¨ç¢¼
                        let text = '';
                        try {
                            text = new TextDecoder('utf-8').decode(arrayBuffer);
                            if (text.includes('ï¿½')) {
                                text = new TextDecoder('big5').decode(arrayBuffer);
                            }
                        } catch (e) {
                            text = new TextDecoder('utf-8', { fatal: false }).decode(arrayBuffer);
                        }
                        // ç§»é™¤ HTML æ¨™ç±¤
                        if (f.type === 'html' || f.type === 'htm') {
                            text = text.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
                                       .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
                                       .replace(/<[^>]+>/g, ' ')
                                       .replace(/&nbsp;/g, ' ')
                                       .replace(/\s+/g, ' ');
                        }
                        f.content = text.substring(0, 8000);
                        break;
                }
            } catch (err) {
                console.error('Parse error for', f.name, err);
                f.content = '[è§£æéŒ¯èª¤: ' + err.message + ']';
            }
            
            // è®“ UI æœ‰æ©Ÿæœƒæ›´æ–°
            if (i % 5 === 0) {
                await new Promise(r => setTimeout(r, 10));
            }
        }
        
        statusText.textContent = `âœ… å®Œæˆï¼å·²è¼‰å…¥ ${files.length} å€‹æª”æ¡ˆï¼Œå¯é–‹å§‹æ™ºèƒ½åˆ†æ`;
        progressFill.style.width = '100%';
        
        filteredFiles = [...files];
        renderTable();
        
        smartAnalyzeBtn.disabled = false;
        applyRulesBtn.disabled = false;
        exportBatBtn.disabled = false;
        previewBatBtn.disabled = false;
    });

    // æ™ºèƒ½åˆ†æ
    smartAnalyzeBtn.addEventListener('click', async () => {
        statusText.innerHTML = '<span class="loading"></span> æ­£åœ¨é€²è¡Œæ™ºèƒ½åˆ†æ...';
        smartAnalyzeBtn.disabled = true;
        
        await new Promise(r => setTimeout(r, 50));
        
        for (let i = 0; i < files.length; i++) {
            const f = files[i];
            const analysis = SmartAnalyzer.analyze(f);
            
            f.tags = [...new Set([...f.tags, ...analysis.tags])];
            
            if (analysis.suggestedName !== f.name) {
                f.suggestedName = analysis.suggestedName;
            }
            
            if (analysis.suggestedFolder && !f.suggestedFolder) {
                f.suggestedFolder = analysis.suggestedFolder;
            }
            
            f.analyzed = true;
            f.analysisResult = analysis;
            
            progressFill.style.width = ((i + 1) / files.length * 100) + '%';
        }
        
        filteredFiles = [...files];
        renderTable();
        updateStats();
        
        statusText.textContent = `ğŸ§  æ™ºèƒ½åˆ†æå®Œæˆï¼å·²è™•ç† ${files.length} å€‹æª”æ¡ˆ`;
        smartAnalyzeBtn.disabled = false;
    });

    // æœå°‹åŠŸèƒ½
    searchBox.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase().trim();
        if (!query) {
            filteredFiles = [...files];
        } else {
            filteredFiles = files.filter(f => 
                f.name.toLowerCase().includes(query) ||
                f.content.toLowerCase().includes(query) ||
                f.tags.some(t => t.toLowerCase().includes(query)) ||
                f.suggestedName.toLowerCase().includes(query) ||
                f.suggestedFolder.toLowerCase().includes(query)
            );
        }
        renderTable();
    });

    // æ¸²æŸ“è¡¨æ ¼
    function renderTable() {
        if (filteredFiles.length === 0) {
            fileTableBody.innerHTML = `<tr><td colspan="6" class="empty-state">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                    <path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
                </svg>
                <div>${files.length > 0 ? 'æ²’æœ‰æ‰¾åˆ°ç¬¦åˆçš„æª”æ¡ˆ' : 'è«‹é¸æ“‡è³‡æ–™å¤¾ä»¥é–‹å§‹åˆ†æ'}</div>
            </td></tr>`;
            document.getElementById('fileCountDisplay').textContent = '0';
            return;
        }

        fileTableBody.innerHTML = filteredFiles.map((f, idx) => {
            const globalIdx = files.indexOf(f);
            const previewText = f.content.substring(0, 80).replace(/</g, '&lt;').replace(/>/g, '&gt;');
            const isRenamed = f.suggestedName !== f.name;
            
            return `
            <tr data-idx="${globalIdx}">
                <td class="checkbox-col">
                    <input type="checkbox" class="file-check" ${f.selected ? 'checked' : ''}>
                </td>
                <td>
                    <span class="type-badge type-${f.type}">${f.type}</span>
                </td>
                <td title="${escapeHtml(f.path)}">
                    <div style="max-width:180px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:500;">
                        ${escapeHtml(f.name)}
                    </div>
                    <div class="preview-text" onclick="showContent(${globalIdx})">${previewText}...</div>
                </td>
                <td>
                    <input type="text" value="${escapeHtml(f.suggestedName)}" class="suggested-name" 
                           style="${isRenamed ? 'border-color:#f5af19;background:rgba(245,175,25,0.1);' : ''}">
                    ${f.analyzed ? '<span class="ai-badge">AI</span>' : ''}
                </td>
                <td>
                    <input type="text" value="${escapeHtml(f.suggestedFolder)}" class="suggested-folder"
                           placeholder="ç›®æ¨™è³‡æ–™å¤¾" style="${f.suggestedFolder ? 'border-color:#38ef7d;' : ''}">
                </td>
                <td>
                    ${f.tags.map(t => `<span class="tag ${f.analyzed ? 'tag-auto' : ''}">${escapeHtml(t)}</span>`).join('')}
                </td>
            </tr>`;
        }).join('');

        document.getElementById('fileCountDisplay').textContent = filteredFiles.length;
        
        // ç¶å®šäº‹ä»¶
        document.querySelectorAll('.file-check').forEach(cb => {
            cb.addEventListener('change', function() {
                const idx = parseInt(this.closest('tr').dataset.idx);
                files[idx].selected = this.checked;
                updateStats();
            });
        });
        
        document.querySelectorAll('.suggested-name').forEach(input => {
            input.addEventListener('change', function() {
                const idx = parseInt(this.closest('tr').dataset.idx);
                files[idx].suggestedName = this.value;
                updateStats();
            });
        });
        
        document.querySelectorAll('.suggested-folder').forEach(input => {
            input.addEventListener('change', function() {
                const idx = parseInt(this.closest('tr').dataset.idx);
                files[idx].suggestedFolder = this.value;
            });
        });

        updateStats();
    }

    // é¡¯ç¤ºå…§å®¹
    function showContent(idx) {
        const f = files[idx];
        document.getElementById('contentModalTitle').textContent = 'ğŸ“„ ' + f.name;
        
        let content = f.content;
        if (f.analysisResult) {
            content = `ã€æ™ºèƒ½åˆ†æçµæœã€‘\n`;
            content += `æ—¥æœŸ: ${f.analysisResult.dates.join(', ') || 'æœªåµæ¸¬'}\n`;
            content += `å…¬å¸: ${f.analysisResult.companies.join(', ') || 'æœªåµæ¸¬'}\n`;
            content += `é¡å‹: ${f.analysisResult.documentType || 'æœªåˆ†é¡'}\n`;
            content += `æ¨™ç±¤: ${f.analysisResult.tags.join(', ') || 'ç„¡'}\n`;
            content += `\n${'â”€'.repeat(40)}\n\n`;
            content += `ã€æª”æ¡ˆå…§å®¹ã€‘\n${f.content}`;
        }
        
        document.getElementById('contentPreview').textContent = content;
        document.getElementById('contentModal').classList.add('active');
    }
    window.showContent = showContent;

    function closeContentModal() {
        document.getElementById('contentModal').classList.remove('active');
    }
    window.closeContentModal = closeContentModal;

    // å…¨é¸
    checkAll.addEventListener('change', () => {
        filteredFiles.forEach(f => f.selected = checkAll.checked);
        renderTable();
    });

    document.getElementById('selectAllBtn').addEventListener('click', () => {
        const allSelected = filteredFiles.every(f => f.selected);
        filteredFiles.forEach(f => f.selected = !allSelected);
        checkAll.checked = !allSelected;
        renderTable();
    });

    // æ›´æ–°çµ±è¨ˆ
    function updateStats() {
        document.getElementById('totalFiles').textContent = files.length;
        document.getElementById('pdfCount').textContent = files.filter(f => f.type === 'pdf').length;
        document.getElementById('docxCount').textContent = files.filter(f => f.type === 'docx').length;
        document.getElementById('xlsxCount').textContent = files.filter(f => ['xlsx', 'xls'].includes(f.type)).length;
        document.getElementById('txtCount').textContent = files.filter(f => ['txt', 'html', 'htm', 'xml', 'csv'].includes(f.type)).length;
        document.getElementById('taggedCount').textContent = files.filter(f => f.tags.length > 0).length;
        document.getElementById('renamedCount').textContent = files.filter(f => f.suggestedName !== f.name).length;
    }

    // å–å¾—è¦å‰‡
    function getRules() {
        const rules = [];
        document.querySelectorAll('.rule-item').forEach(item => {
            const keyword = item.querySelector('.rule-keyword')?.value?.trim();
            const tag = item.querySelector('.rule-tag')?.value?.trim();
            const folder = item.querySelector('.rule-folder')?.value?.trim();
            const format = item.querySelector('.rule-format')?.value?.trim();
            
            if (keyword) {
                rules.push({ keyword, tag, folder, format });
            }
        });
        return rules;
    }

    // å¥—ç”¨è‡ªè¨‚è¦å‰‡
    applyRulesBtn.addEventListener('click', () => {
        const rules = getRules();
        let matchCount = 0;
        
        files.forEach(f => {
            const searchText = (f.name + ' ' + f.content).toLowerCase();
            
            rules.forEach(rule => {
                const keywords = rule.keyword.split(',').map(k => k.trim().toLowerCase());
                const matched = keywords.some(kw => kw && searchText.includes(kw));
                
                if (matched) {
                    matchCount++;
                    
                    if (rule.tag && !f.tags.includes(rule.tag)) {
                        f.tags.push(rule.tag);
                    }
                    
                    if (rule.folder) {
                        f.suggestedFolder = rule.folder;
                    }
                    
                    if (rule.format) {
                        f.suggestedName = applyNameFormat(f, rule.format);
                    }
                }
            });
        });
        
        filteredFiles = [...files];
        if (searchBox.value) {
            searchBox.dispatchEvent(new Event('input'));
        } else {
            renderTable();
        }
        
        statusText.textContent = `âœ… è¦å‰‡å·²å¥—ç”¨ï¼åŒ¹é… ${matchCount} æ¬¡`;
    });

    // å¥—ç”¨æª”åæ ¼å¼
    function applyNameFormat(file, format) {
        const ext = '.' + file.name.split('.').pop();
        const baseName = file.name.replace(/\.[^.]+$/, '');
        
        let result = format;
        
        // æ›¿æ›è®Šæ•¸
        const analysis = file.analysisResult || SmartAnalyzer.analyze(file);
        
        result = result.replace(/\{date\}/gi, analysis.dates[0] || '');
        result = result.replace(/\{company\}/gi, (analysis.companies[0] || '').replace(/(è‚¡ä»½æœ‰é™å…¬å¸|æœ‰é™å…¬å¸)$/, ''));
        result = result.replace(/\{original\}/gi, baseName);
        result = result.replace(/\{type\}/gi, file.type.toUpperCase());
        
        // æ¸…ç†
        result = result.replace(/_+/g, '_').replace(/^_|_$/g, '');
        
        if (!result.includes('.')) {
            result += ext;
        }
        
        return result;
    }

    // æ–°å¢è¦å‰‡
    addRuleBtn.addEventListener('click', () => {
        const ruleHtml = `
            <div class="rule-item">
                <label>é—œéµå­—ï¼ˆé€—è™Ÿåˆ†éš”ï¼‰</label>
                <input type="text" class="rule-keyword" placeholder="ä¾‹å¦‚ï¼šåˆç´„, contract, å”è­°">
                <label>æ¨™ç±¤</label>
                <input type="text" class="rule-tag" placeholder="ä¾‹å¦‚ï¼šåˆç´„æ–‡ä»¶">
                <label>ç›®æ¨™è³‡æ–™å¤¾</label>
                <input type="text" class="rule-folder" placeholder="ä¾‹å¦‚ï¼š01_åˆç´„">
                <label>æª”åæ ¼å¼</label>
                <input type="text" class="rule-format" placeholder="ä¾‹å¦‚ï¼š[åˆç´„] {date}_{company}_{original}">
                <div style="font-size:10px;color:#666;margin-top:5px;">å¯ç”¨è®Šæ•¸: {date}, {company}, {original}, {type}</div>
                <div class="rule-actions">
                    <button class="btn btn-warning remove-rule">âœ– åˆªé™¤</button>
                </div>
            </div>
        `;
        rulesContainer.insertAdjacentHTML('beforeend', ruleHtml);
        bindRuleEvents();
    });

    // ç¶å®šè¦å‰‡åˆªé™¤äº‹ä»¶
    function bindRuleEvents() {
        document.querySelectorAll('.remove-rule').forEach(btn => {
            btn.onclick = function() {
                if (document.querySelectorAll('.rule-item').length > 1) {
                    this.closest('.rule-item').remove();
                }
            };
        });
    }
    bindRuleEvents();

    // è¦å‰‡ç®¡ç†
    document.getElementById('saveRulesBtn').addEventListener('click', () => {
        const rules = getRules();
        const blob = new Blob([JSON.stringify(rules, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'file-organize-rules.json';
        a.click();
        statusText.textContent = 'ğŸ’¾ è¦å‰‡å·²å„²å­˜';
    });

    document.getElementById('loadRulesBtn').addEventListener('click', () => {
        document.getElementById('loadRulesInput').click();
    });

    document.getElementById('loadRulesInput').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        try {
            const text = await file.text();
            const rules = JSON.parse(text);
            
            rulesContainer.innerHTML = '';
            rules.forEach(rule => {
                const ruleHtml = `
                    <div class="rule-item">
                        <label>é—œéµå­—ï¼ˆé€—è™Ÿåˆ†éš”ï¼‰</label>
                        <input type="text" class="rule-keyword" value="${escapeHtml(rule.keyword || '')}">
                        <label>æ¨™ç±¤</label>
                        <input type="text" class="rule-tag" value="${escapeHtml(rule.tag || '')}">
                        <label>ç›®æ¨™è³‡æ–™å¤¾</label>
                        <input type="text" class="rule-folder" value="${escapeHtml(rule.folder || '')}">
                        <label>æª”åæ ¼å¼</label>
                        <input type="text" class="rule-format" value="${escapeHtml(rule.format || rule.prefix || '')}">
                        <div style="font-size:10px;color:#666;margin-top:5px;">å¯ç”¨è®Šæ•¸: {date}, {company}, {original}, {type}</div>
                        <div class="rule-actions">
                            <button class="btn btn-warning remove-rule">âœ– åˆªé™¤</button>
                        </div>
                    </div>
                `;
                rulesContainer.insertAdjacentHTML('beforeend', ruleHtml);
            });
            bindRuleEvents();
            statusText.textContent = 'ğŸ“‚ è¦å‰‡å·²è¼‰å…¥';
        } catch (err) {
            statusText.textContent = 'âŒ è¦å‰‡æª”æ¡ˆæ ¼å¼éŒ¯èª¤';
        }
        e.target.value = '';
    });

    document.getElementById('clearRulesBtn').addEventListener('click', () => {
        if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰è‡ªè¨‚è¦å‰‡å—ï¼Ÿ')) {
            rulesContainer.innerHTML = `
                <div class="rule-item">
                    <label>é—œéµå­—ï¼ˆé€—è™Ÿåˆ†éš”ï¼‰</label>
                    <input type="text" class="rule-keyword" placeholder="ä¾‹å¦‚ï¼šåˆç´„, contract, å”è­°">
                    <label>æ¨™ç±¤</label>
                    <input type="text" class="rule-tag" placeholder="ä¾‹å¦‚ï¼šåˆç´„æ–‡ä»¶">
                    <label>ç›®æ¨™è³‡æ–™å¤¾</label>
                    <input type="text" class="rule-folder" placeholder="ä¾‹å¦‚ï¼š01_åˆç´„">
                    <label>æª”åæ ¼å¼</label>
                    <input type="text" class="rule-format" placeholder="ä¾‹å¦‚ï¼š[åˆç´„] {date}_{company}_{original}">
                    <div style="font-size:10px;color:#666;margin-top:5px;">å¯ç”¨è®Šæ•¸: {date}, {company}, {original}, {type}</div>
                    <div class="rule-actions">
                        <button class="btn btn-warning remove-rule">âœ– åˆªé™¤</button>
                    </div>
                </div>
            `;
            bindRuleEvents();
            statusText.textContent = 'ğŸ—‘ï¸ è¦å‰‡å·²æ¸…é™¤';
        }
    });

    // ç”¢ç”Ÿ BAT
    function generateBat() {
        const selectedFiles = files.filter(f => f.selected);
        if (selectedFiles.length === 0) {
            alert('è«‹è‡³å°‘é¸æ“‡ä¸€å€‹æª”æ¡ˆï¼');
            return '';
        }

        let bat = '@echo off\r\n';
        bat += 'chcp 65001 > nul\r\n';
        bat += 'setlocal enabledelayedexpansion\r\n\r\n';
        bat += 'echo â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\r\n';
        bat += 'echo â•‘         æ™ºèƒ½æª”æ¡ˆæ•´ç†æ‰¹æ¬¡è™•ç†å·¥å…·           â•‘\r\n';
        bat += 'echo â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\r\n';
        bat += 'echo â•‘  ç”¢ç”Ÿæ™‚é–“: ' + new Date().toLocaleString('zh-TW').padEnd(31) + 'â•‘\r\n';
        bat += 'echo â•‘  æª”æ¡ˆæ•¸é‡: ' + (selectedFiles.length + ' å€‹').padEnd(31) + 'â•‘\r\n';
        bat += 'echo â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n';
        bat += 'echo.\r\n\r\n';
        
        bat += 'set "BASE_DIR=%~dp0"\r\n';
        bat += 'cd /d "%BASE_DIR%"\r\n\r\n';

        // æ”¶é›†æ‰€æœ‰è³‡æ–™å¤¾
        const folders = new Set();
        selectedFiles.forEach(f => {
            if (f.suggestedFolder) {
                // æ”¯æ´å·¢ç‹€è³‡æ–™å¤¾
                const parts = f.suggestedFolder.split(/[\/\\]/).filter(p => p);
                let path = '';
                parts.forEach(part => {
                    path = path ? path + '\\' + part : part;
                    folders.add(path);
                });
            }
        });

        // å»ºç«‹è³‡æ–™å¤¾
        if (folders.size > 0) {
            bat += 'echo [Step 1/3] å»ºç«‹è³‡æ–™å¤¾çµæ§‹...\r\n';
            bat += 'echo.\r\n';
            [...folders].sort().forEach(folder => {
                bat += `if not exist "${folder}" (\r\n`;
                bat += `    mkdir "${folder}"\r\n`;
                bat += `    echo   [+] å»ºç«‹: ${folder}\r\n`;
                bat += `)\r\n`;
            });
            bat += 'echo.\r\n\r\n';
        }

        // è™•ç†æª”æ¡ˆ
        bat += 'echo [Step 2/3] è™•ç†æª”æ¡ˆ...\r\n';
        bat += 'echo.\r\n';
        bat += 'set /a SUCCESS=0\r\n';
        bat += 'set /a FAILED=0\r\n\r\n';

        selectedFiles.forEach((f, i) => {
            const sourcePath = f.path.replace(/\//g, '\\');
            const newName = f.suggestedName.replace(/[<>:"|?*]/g, '_'); // ç§»é™¤éæ³•å­—å…ƒ
            const targetFolder = f.suggestedFolder ? f.suggestedFolder.replace(/\//g, '\\') : '';
            
            bat += `echo [${i + 1}/${selectedFiles.length}] ${f.name}\r\n`;
            
            if (targetFolder && newName !== f.name) {
                // ç§»å‹•ä¸¦é‡å‘½å
                bat += `if exist "${sourcePath}" (\r\n`;
                bat += `    copy /Y "${sourcePath}" "${targetFolder}\\${newName}" > nul 2>&1\r\n`;
                bat += `    if !errorlevel! == 0 (\r\n`;
                bat += `        del /Q "${sourcePath}" > nul 2>&1\r\n`;
                bat += `        echo       â†’ ${targetFolder}\\${newName}\r\n`;
                bat += `        set /a SUCCESS+=1\r\n`;
                bat += `    ) else (\r\n`;
                bat += `        echo       [!] è™•ç†å¤±æ•—\r\n`;
                bat += `        set /a FAILED+=1\r\n`;
                bat += `    )\r\n`;
                bat += `) else (\r\n`;
                bat += `    echo       [!] æ‰¾ä¸åˆ°æª”æ¡ˆ\r\n`;
                bat += `    set /a FAILED+=1\r\n`;
                bat += `)\r\n\r\n`;
            } else if (targetFolder) {
                // åªç§»å‹•
                bat += `if exist "${sourcePath}" (\r\n`;
                bat += `    move /Y "${sourcePath}" "${targetFolder}\\" > nul 2>&1\r\n`;
                bat += `    if !errorlevel! == 0 (\r\n`;
                bat += `        echo       â†’ ${targetFolder}\\\r\n`;
                bat += `        set /a SUCCESS+=1\r\n`;
                bat += `    ) else (\r\n`;
                bat += `        echo       [!] ç§»å‹•å¤±æ•—\r\n`;
                bat += `        set /a FAILED+=1\r\n`;
                bat += `    )\r\n`;
                bat += `) else (\r\n`;
                bat += `    echo       [!] æ‰¾ä¸åˆ°æª”æ¡ˆ\r\n`;
                bat += `    set /a FAILED+=1\r\n`;
                bat += `)\r\n\r\n`;
            } else if (newName !== f.name) {
                // åªé‡å‘½å
                const dir = sourcePath.includes('\\') ? sourcePath.substring(0, sourcePath.lastIndexOf('\\') + 1) : '';
                bat += `if exist "${sourcePath}" (\r\n`;
                bat += `    ren "${sourcePath}" "${newName}" > nul 2>&1\r\n`;
                bat += `    if !errorlevel! == 0 (\r\n`;
                bat += `        echo       â†’ ${newName}\r\n`;
                bat += `        set /a SUCCESS+=1\r\n`;
                bat += `    ) else (\r\n`;
                bat += `        echo       [!] é‡å‘½åå¤±æ•—\r\n`;
                bat += `        set /a FAILED+=1\r\n`;
                bat += `    )\r\n`;
                bat += `) else (\r\n`;
                bat += `    echo       [!] æ‰¾ä¸åˆ°æª”æ¡ˆ\r\n`;
                bat += `    set /a FAILED+=1\r\n`;
                bat += `)\r\n\r\n`;
            } else {
                bat += `echo       (ç„¡è®Šæ›´)\r\n\r\n`;
            }
        });
        
        bat += 'echo.\r\n';
        bat += 'echo [Step 3/3] å®Œæˆï¼\r\n';
        bat += 'echo.\r\n';
        bat += 'echo â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n';
        bat += 'echo   æˆåŠŸ: %SUCCESS% å€‹  /  å¤±æ•—: %FAILED% å€‹\r\n';
        bat += 'echo â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n';
        bat += 'echo.\r\n';
        bat += 'pause\r\n';
        bat += 'endlocal\r\n';

        return bat;
    }

    // é è¦½ BAT
    previewBatBtn.addEventListener('click', () => {
        generatedBat = generateBat();
        if (generatedBat) {
            document.getElementById('batPreviewContent').textContent = generatedBat;
            document.getElementById('batPreviewModal').classList.add('active');
        }
    });

    function closeBatPreview() {
        document.getElementById('batPreviewModal').classList.remove('active');
    }
    window.closeBatPreview = closeBatPreview;

    // åŒ¯å‡º BAT
    exportBatBtn.addEventListener('click', () => {
        generatedBat = generateBat();
        if (generatedBat) {
            downloadBat();
        }
    });

    function downloadBat() {
        if (!generatedBat) generatedBat = generateBat();
        if (!generatedBat) return;
        
        // ä½¿ç”¨ BOM ç¢ºä¿ Windows æ­£ç¢ºè­˜åˆ¥ UTF-8
        const BOM = '\uFEFF';
        const blob = new Blob([BOM + generatedBat], { type: 'text/plain;charset=utf-8' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'organize-files-' + new Date().toISOString().slice(0,10) + '.bat';
        a.click();
        closeBatPreview();
        statusText.textContent = 'âœ… BAT æª”æ¡ˆå·²ä¸‹è¼‰ï¼è«‹å°‡æª”æ¡ˆæ”¾åˆ°è³‡æ–™å¤¾æ ¹ç›®éŒ„åŸ·è¡Œ';
    }
    window.downloadBat = downloadBat;

    function copyBat() {
        if (!generatedBat) return;
        navigator.clipboard.writeText(generatedBat).then(() => {
            statusText.textContent = 'ğŸ“‹ å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿';
        });
    }
    window.copyBat = copyBat;

    // å·¥å…·å‡½æ•¸
    function escapeHtml(str) {
        if (!str) return '';
        return String(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;');
    }

    // è‡ªå‹•å„²å­˜è¦å‰‡åˆ° localStorage
    setInterval(() => {
        try {
            const rules = getRules();
            if (rules.length > 0) {
                localStorage.setItem('smartFileOrganizerRules', JSON.stringify(rules));
            }
        } catch (e) {}
    }, 5000);

    // è¼‰å…¥å„²å­˜çš„è¦å‰‡
    window.addEventListener('load', () => {
        try {
            const saved = localStorage.getItem('smartFileOrganizerRules');
            if (saved) {
                const rules = JSON.parse(saved);
                if (rules.length > 0) {
                    rulesContainer.innerHTML = '';
                    rules.forEach(rule => {
                        const ruleHtml = `
                            <div class="rule-item">
                                <label>é—œéµå­—ï¼ˆé€—è™Ÿåˆ†éš”ï¼‰</label>
                                <input type="text" class="rule-keyword" value="${escapeHtml(rule.keyword || '')}">
                                <label>æ¨™ç±¤</label>
                                <input type="text" class="rule-tag" value="${escapeHtml(rule.tag || '')}">
                                <label>ç›®æ¨™è³‡æ–™å¤¾</label>
                                <input type="text" class="rule-folder" value="${escapeHtml(rule.folder || '')}">
                                <label>æª”åæ ¼å¼</label>
                                <input type="text" class="rule-format" value="${escapeHtml(rule.format || '')}">
                                <div style="font-size:10px;color:#666;margin-top:5px;">å¯ç”¨è®Šæ•¸: {date}, {company}, {original}, {type}</div>
                                <div class="rule-actions">
                                    <button class="btn btn-warning remove-rule">âœ– åˆªé™¤</button>
                                </div>
                            </div>
                        `;
                        rulesContainer.insertAdjacentHTML('beforeend', ruleHtml);
                    });
                    bindRuleEvents();
                }
            }
        } catch (e) {}
    });

    // æ‹–æ”¾æ”¯æ´
    document.body.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
    });

    document.body.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (e.dataTransfer.items) {
            // æç¤ºç”¨æˆ¶ä½¿ç”¨é¸æ“‡è³‡æ–™å¤¾æŒ‰éˆ•
            statusText.textContent = 'âš ï¸ è«‹ä½¿ç”¨ã€Œé¸æ“‡è³‡æ–™å¤¾ã€æŒ‰éˆ•ä¾†è¼‰å…¥æª”æ¡ˆ';
        }
    });

    // ============ è‡ªè¨‚åµæ¸¬é …ç›®åŠŸèƒ½ ============
    let customDetectItems = [];
    let customDetectCounter = 0;

    // é–‹å•Ÿæ–°å¢åµæ¸¬é …ç›® Modal
    document.getElementById('addDetectItemBtn').addEventListener('click', () => {
        document.getElementById('newDetectName').value = '';
        document.getElementById('newDetectKeywords').value = '';
        document.getElementById('newDetectTag').value = '';
        document.getElementById('newDetectFolder').value = '';
        document.getElementById('addDetectModal').classList.add('active');
    });

    function closeAddDetectModal() {
        document.getElementById('addDetectModal').classList.remove('active');
    }
    window.closeAddDetectModal = closeAddDetectModal;

    // å„²å­˜è‡ªè¨‚åµæ¸¬é …ç›®
    function saveCustomDetectItem() {
        const name = document.getElementById('newDetectName').value.trim();
        const keywords = document.getElementById('newDetectKeywords').value.trim();
        const tag = document.getElementById('newDetectTag').value.trim() || name;
        const folder = document.getElementById('newDetectFolder').value.trim();

        if (!name || !keywords) {
            alert('è«‹å¡«å¯«é …ç›®åç¨±å’Œé—œéµå­—ï¼');
            return;
        }

        const itemId = 'customDetect_' + (++customDetectCounter);
        const keywordArray = keywords.split(',').map(k => k.trim().toLowerCase()).filter(k => k);

        // åŠ å…¥è‡ªè¨‚é …ç›®åˆ—è¡¨
        const customItem = {
            id: itemId,
            name: name,
            keywords: keywordArray,
            tag: tag,
            folder: folder,
            enabled: true
        };
        customDetectItems.push(customItem);

        // å‹•æ…‹æ·»åŠ åˆ° SmartAnalyzer.documentTypes
        SmartAnalyzer.documentTypes[itemId] = {
            keywords: keywordArray,
            folder: folder,
            tag: tag,
            isCustom: true
        };

        // æ¸²æŸ“è‡ªè¨‚é …ç›® UI
        renderCustomDetectItems();
        
        // å„²å­˜åˆ° localStorage
        saveCustomDetectItemsToStorage();

        closeAddDetectModal();
        statusText.textContent = `âœ… å·²æ–°å¢åµæ¸¬é …ç›®ï¼š${name}`;
    }
    window.saveCustomDetectItem = saveCustomDetectItem;

    // æ¸²æŸ“è‡ªè¨‚åµæ¸¬é …ç›®
    function renderCustomDetectItems() {
        const container = document.getElementById('customDetectItems');
        
        if (customDetectItems.length === 0) {
            container.innerHTML = '';
            return;
        }

        container.innerHTML = `
            <div style="font-size:11px;color:#888;margin-bottom:5px;">ğŸ“Œ è‡ªè¨‚é …ç›®ï¼š</div>
            <div class="smart-options">
                ${customDetectItems.map(item => `
                    <label style="position:relative;padding-right:25px;" data-custom-id="${item.id}">
                        <input type="checkbox" data-custom-type="${item.id}" ${item.enabled ? 'checked' : ''}>
                        ${escapeHtml(item.name)}
                        <span class="custom-detect-delete" onclick="deleteCustomDetectItem('${item.id}')" 
                              style="position:absolute;right:5px;top:50%;transform:translateY(-50%);
                                     cursor:pointer;color:#f5576c;font-weight:bold;font-size:14px;"
                              title="åˆªé™¤æ­¤é …ç›®">Ã—</span>
                    </label>
                `).join('')}
            </div>
        `;

        // ç¶å®š checkbox äº‹ä»¶
        container.querySelectorAll('input[data-custom-type]').forEach(cb => {
            cb.addEventListener('change', function() {
                const itemId = this.dataset.customType;
                const item = customDetectItems.find(i => i.id === itemId);
                if (item) {
                    item.enabled = this.checked;
                    saveCustomDetectItemsToStorage();
                }
            });
        });
    }

    // åˆªé™¤è‡ªè¨‚åµæ¸¬é …ç›®
    function deleteCustomDetectItem(itemId) {
        if (!confirm('ç¢ºå®šè¦åˆªé™¤æ­¤åµæ¸¬é …ç›®å—ï¼Ÿ')) return;

        // å¾åˆ—è¡¨ç§»é™¤
        customDetectItems = customDetectItems.filter(i => i.id !== itemId);

        // å¾ SmartAnalyzer ç§»é™¤
        delete SmartAnalyzer.documentTypes[itemId];

        // é‡æ–°æ¸²æŸ“
        renderCustomDetectItems();
        
        // å„²å­˜åˆ° localStorage
        saveCustomDetectItemsToStorage();

        statusText.textContent = 'ğŸ—‘ï¸ å·²åˆªé™¤åµæ¸¬é …ç›®';
    }
    window.deleteCustomDetectItem = deleteCustomDetectItem;

    // å„²å­˜è‡ªè¨‚é …ç›®åˆ° localStorage
    function saveCustomDetectItemsToStorage() {
        try {
            localStorage.setItem('customDetectItems', JSON.stringify(customDetectItems));
        } catch (e) {}
    }

    // å¾ localStorage è¼‰å…¥è‡ªè¨‚é …ç›®
    function loadCustomDetectItemsFromStorage() {
        try {
            const saved = localStorage.getItem('customDetectItems');
            if (saved) {
                customDetectItems = JSON.parse(saved);
                customDetectItems.forEach(item => {
                    // é‚„åŸåˆ° SmartAnalyzer
                    SmartAnalyzer.documentTypes[item.id] = {
                        keywords: item.keywords,
                        folder: item.folder,
                        tag: item.tag,
                        isCustom: true
                    };
                    customDetectCounter = Math.max(customDetectCounter, parseInt(item.id.split('_')[1]) || 0);
                });
                renderCustomDetectItems();
            }
        } catch (e) {}
    }

    // ä¿®æ”¹ SmartAnalyzer.analyze ä»¥æ”¯æ´è‡ªè¨‚é …ç›®å’Œæ–°çš„ checkbox çµæ§‹
    const originalAnalyze = SmartAnalyzer.analyze.bind(SmartAnalyzer);
    SmartAnalyzer.analyze = function(file) {
        const result = {
            dates: [],
            companies: [],
            documentType: null,
            tags: [],
            suggestedName: file.name,
            suggestedFolder: ''
        };
        
        const searchText = (file.name + ' ' + file.content).toLowerCase();
        const originalText = file.name + ' ' + file.content;
        
        // æå–æ—¥æœŸ
        if (document.getElementById('detectDate')?.checked) {
            for (const pattern of this.datePatterns) {
                const matches = originalText.matchAll(new RegExp(pattern.source, pattern.flags));
                for (const match of matches) {
                    let dateStr = this.normalizeDate(match);
                    if (dateStr && !result.dates.includes(dateStr)) {
                        result.dates.push(dateStr);
                    }
                }
            }
        }
        
        // æå–å…¬å¸åç¨±
        if (document.getElementById('detectCompany')?.checked) {
            for (const pattern of this.companyPatterns) {
                const matches = originalText.matchAll(new RegExp(pattern.source, pattern.flags));
                for (const match of matches) {
                    let company = match[0].trim();
                    if (company.length >= 4 && company.length <= 30) {
                        if (!result.companies.some(c => c.includes(company) || company.includes(c))) {
                            result.companies.push(company);
                        }
                    }
                }
            }
        }
        
        // è­˜åˆ¥æ–‡ä»¶é¡å‹ - ä½¿ç”¨æ–°çš„ checkbox çµæ§‹
        for (const [type, config] of Object.entries(this.documentTypes)) {
            let isEnabled = false;
            
            // æª¢æŸ¥æ˜¯å¦å•Ÿç”¨
            if (config.isCustom) {
                // è‡ªè¨‚é …ç›®
                const cb = document.querySelector(`input[data-custom-type="${type}"]`);
                isEnabled = cb ? cb.checked : false;
            } else {
                // å…§å»ºé …ç›®
                const cb = document.querySelector(`input[data-type="${type}"]`);
                isEnabled = cb ? cb.checked : true;
            }
            
            if (!isEnabled) continue;
            
            const matched = config.keywords.some(kw => searchText.includes(kw.toLowerCase()));
            if (matched) {
                if (!result.documentType) {
                    result.documentType = type;
                    result.suggestedFolder = config.folder;
                }
                if (!result.tags.includes(config.tag)) {
                    result.tags.push(config.tag);
                }
            }
        }
        
        // ç”Ÿæˆå»ºè­°æª”å
        result.suggestedName = this.generateFileName(file, result);
        
        return result;
    };

    // é é¢è¼‰å…¥æ™‚è¼‰å…¥è‡ªè¨‚é …ç›®
    window.addEventListener('load', () => {
        loadCustomDetectItemsFromStorage();
    });

    // ============ å‰¯æª”åç¯©é¸åŠŸèƒ½ ============
    let allRawFiles = []; // å„²å­˜åŸå§‹æª”æ¡ˆåˆ—è¡¨ï¼ˆæœªç¯©é¸ï¼‰
    let extFilter = {}; // å‰¯æª”åç¯©é¸ç‹€æ…‹
    
    // æ ¼å¼åŒ–æª”æ¡ˆå¤§å°
    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }
    
    // åˆ†æå‰¯æª”åçµ±è¨ˆ
    function analyzeExtensions(fileList) {
        const stats = {};
        fileList.forEach(f => {
            const ext = f.name.split('.').pop().toLowerCase();
            if (!stats[ext]) {
                stats[ext] = { count: 0, size: 0, files: [] };
            }
            stats[ext].count++;
            stats[ext].size += f.size;
            stats[ext].files.push(f);
        });
        return stats;
    }
    
    // æ¸²æŸ“å‰¯æª”åç¯©é¸å€åŸŸ
    function renderExtFilter(extStats) {
        const section = document.getElementById('extFilterSection');
        const list = document.getElementById('extFilterList');
        const summary = document.getElementById('extFilterSummary');
        
        // ä¾æª”æ¡ˆæ•¸é‡æ’åº
        const sortedExts = Object.entries(extStats)
            .sort((a, b) => b[1].count - a[1].count);
        
        // åˆå§‹åŒ–æ‰€æœ‰å‰¯æª”åç‚ºå‹¾é¸
        extFilter = {};
        sortedExts.forEach(([ext]) => {
            extFilter[ext] = true;
        });
        
        // é¡å‹é¡è‰²å°æ‡‰
        const typeColors = {
            pdf: '#e74c3c',
            docx: '#3498db', doc: '#3498db',
            xlsx: '#27ae60', xls: '#27ae60',
            txt: '#9b59b6',
            html: '#f39c12', htm: '#f39c12',
            xml: '#1abc9c',
            csv: '#e67e22'
        };
        
        list.innerHTML = sortedExts.map(([ext, data]) => {
            const color = typeColors[ext] || '#667eea';
            return `
                <label class="ext-filter-item selected" data-ext="${ext}" style="border-left: 3px solid ${color};">
                    <input type="checkbox" data-ext-filter="${ext}" checked>
                    <span class="ext-name" style="color:${color}">.${ext}</span>
                    <span class="ext-count">${data.count} å€‹</span>
                    <span class="ext-size">${formatFileSize(data.size)}</span>
                </label>
            `;
        }).join('');
        
        // æ›´æ–°æ‘˜è¦
        updateExtFilterSummary();
        
        // ç¶å®šäº‹ä»¶
        list.querySelectorAll('input[data-ext-filter]').forEach(cb => {
            cb.addEventListener('change', function() {
                const ext = this.dataset.extFilter;
                extFilter[ext] = this.checked;
                this.closest('.ext-filter-item').classList.toggle('selected', this.checked);
                updateExtFilterSummary();
            });
        });
        
        // é»æ“Šæ•´å€‹é …ç›®ä¹Ÿèƒ½åˆ‡æ›
        list.querySelectorAll('.ext-filter-item').forEach(item => {
            item.addEventListener('click', function(e) {
                if (e.target.type !== 'checkbox') {
                    const cb = this.querySelector('input[type="checkbox"]');
                    cb.checked = !cb.checked;
                    cb.dispatchEvent(new Event('change'));
                }
            });
        });
        
        section.style.display = 'block';
    }
    
    // æ›´æ–°å‰¯æª”åç¯©é¸æ‘˜è¦
    function updateExtFilterSummary() {
        const summary = document.getElementById('extFilterSummary');
        const selectedExts = Object.entries(extFilter).filter(([_, v]) => v).map(([k]) => k);
        const totalExts = Object.keys(extFilter).length;
        
        let selectedCount = 0;
        let selectedSize = 0;
        allRawFiles.forEach(f => {
            const ext = f.name.split('.').pop().toLowerCase();
            if (extFilter[ext]) {
                selectedCount++;
                selectedSize += f.size;
            }
        });
        
        summary.innerHTML = `
            <div>
                <strong>å·²é¸æ“‡:</strong> ${selectedExts.length}/${totalExts} ç¨®é¡å‹ï¼Œ
                å…± <strong>${selectedCount}</strong> å€‹æª”æ¡ˆ (${formatFileSize(selectedSize)})
            </div>
            <div class="ext-priority-hint">
                ğŸ’¡ å–æ¶ˆå‹¾é¸ä¸éœ€è¦è™•ç†çš„æª”æ¡ˆé¡å‹ï¼Œå¯åŠ å¿«è™•ç†é€Ÿåº¦
            </div>
        `;
    }
    
    // å‰¯æª”åå…¨é¸
    document.getElementById('extSelectAll').addEventListener('click', () => {
        Object.keys(extFilter).forEach(ext => extFilter[ext] = true);
        document.querySelectorAll('input[data-ext-filter]').forEach(cb => {
            cb.checked = true;
            cb.closest('.ext-filter-item').classList.add('selected');
        });
        updateExtFilterSummary();
    });
    
    // å‰¯æª”åå–æ¶ˆå…¨é¸
    document.getElementById('extDeselectAll').addEventListener('click', () => {
        Object.keys(extFilter).forEach(ext => extFilter[ext] = false);
        document.querySelectorAll('input[data-ext-filter]').forEach(cb => {
            cb.checked = false;
            cb.closest('.ext-filter-item').classList.remove('selected');
        });
        updateExtFilterSummary();
    });
    
    // å¥—ç”¨å‰¯æª”åç¯©é¸
    document.getElementById('extApplyFilter').addEventListener('click', async () => {
        const selectedExts = Object.entries(extFilter).filter(([_, v]) => v).map(([k]) => k);
        
        if (selectedExts.length === 0) {
            alert('è«‹è‡³å°‘é¸æ“‡ä¸€ç¨®æª”æ¡ˆé¡å‹ï¼');
            return;
        }
        
        // éæ¿¾æª”æ¡ˆ
        const filteredRawFiles = allRawFiles.filter(f => {
            const ext = f.name.split('.').pop().toLowerCase();
            return extFilter[ext];
        });
        
        // é–‹å§‹è™•ç†
        files = filteredRawFiles.map(f => ({
            file: f,
            name: f.name,
            path: f.webkitRelativePath,
            type: f.name.split('.').pop().toLowerCase(),
            size: f.size,
            content: '',
            suggestedName: f.name,
            suggestedFolder: '',
            tags: [],
            selected: true,
            analyzed: false
        }));
        
        if (files.length === 0) {
            statusText.textContent = 'æœªé¸æ“‡ä»»ä½•æª”æ¡ˆ';
            return;
        }
        
        updateStats();
        
        // éš±è—ç¯©é¸å€åŸŸï¼Œé–‹å§‹è§£æ
        document.getElementById('extFilterSection').style.display = 'none';
        
        // è§£ææª”æ¡ˆå…§å®¹
        statusText.innerHTML = '<span class="loading"></span> æ­£åœ¨è§£ææª”æ¡ˆå…§å®¹...';
        
        for (let i = 0; i < files.length; i++) {
            const f = files[i];
            progressFill.style.width = ((i + 1) / files.length * 100) + '%';
            statusText.innerHTML = `<span class="loading"></span> è§£æä¸­: ${f.name} (${i + 1}/${files.length})`;
            
            try {
                const arrayBuffer = await f.file.arrayBuffer();
                
                switch (f.type) {
                    case 'pdf':
                        f.content = await PDFParser.parse(arrayBuffer);
                        break;
                    case 'docx':
                        f.content = await DOCXParser.parse(arrayBuffer);
                        break;
                    case 'xlsx':
                    case 'xls':
                        f.content = await XLSXParser.parse(arrayBuffer);
                        break;
                    case 'txt':
                    case 'html':
                    case 'htm':
                    case 'xml':
                    case 'csv':
                        let text = '';
                        try {
                            text = new TextDecoder('utf-8').decode(arrayBuffer);
                            if (text.includes('ï¿½')) {
                                text = new TextDecoder('big5').decode(arrayBuffer);
                            }
                        } catch (e) {
                            text = new TextDecoder('utf-8', { fatal: false }).decode(arrayBuffer);
                        }
                        if (f.type === 'html' || f.type === 'htm') {
                            text = text.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
                                       .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
                                       .replace(/<[^>]+>/g, ' ')
                                       .replace(/&nbsp;/g, ' ')
                                       .replace(/\s+/g, ' ');
                        }
                        f.content = text.substring(0, 8000);
                        break;
                }
            } catch (err) {
                console.error('Parse error for', f.name, err);
                f.content = '[è§£æéŒ¯èª¤: ' + err.message + ']';
            }
            
            if (i % 5 === 0) {
                await new Promise(r => setTimeout(r, 10));
            }
        }
        
        statusText.textContent = `âœ… å®Œæˆï¼å·²è¼‰å…¥ ${files.length} å€‹æª”æ¡ˆï¼Œå¯é–‹å§‹æ™ºèƒ½åˆ†æ`;
        progressFill.style.width = '100%';
        
        filteredFiles = [...files];
        renderTable();
        
        smartAnalyzeBtn.disabled = false;
        applyRulesBtn.disabled = false;
        exportBatBtn.disabled = false;
        previewBatBtn.disabled = false;
    });

    // ä¿®æ”¹åŸå§‹çš„è³‡æ–™å¤¾é¸æ“‡äº‹ä»¶
    const originalFolderHandler = folderInput.onchange;
    folderInput.removeEventListener('change', originalFolderHandler);
    
    folderInput.addEventListener('change', (e) => {
        const fileList = Array.from(e.target.files);
        const supportedTypes = ['.pdf', '.docx', '.xlsx', '.xls', '.txt', '.html', '.htm', '.xml', '.csv'];
        
        // å„²å­˜æ‰€æœ‰æ”¯æ´çš„åŸå§‹æª”æ¡ˆ
        allRawFiles = fileList.filter(f => {
            const ext = '.' + f.name.split('.').pop().toLowerCase();
            return supportedTypes.includes(ext) && !f.name.startsWith('.');
        });

        if (allRawFiles.length === 0) {
            statusText.textContent = 'æœªæ‰¾åˆ°æ”¯æ´çš„æª”æ¡ˆæ ¼å¼';
            document.getElementById('extFilterSection').style.display = 'none';
            return;
        }

        // åˆ†æå‰¯æª”åä¸¦é¡¯ç¤ºç¯©é¸å€åŸŸ
        const extStats = analyzeExtensions(allRawFiles);
        renderExtFilter(extStats);
        
        // é‡ç½®æª”æ¡ˆåˆ—è¡¨å’ŒæŒ‰éˆ•ç‹€æ…‹
        files = [];
        filteredFiles = [];
        fileTableBody.innerHTML = `<tr><td colspan="6" class="empty-state">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                <path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
            </svg>
            <div>è«‹é¸æ“‡è¦è™•ç†çš„æª”æ¡ˆé¡å‹ï¼Œç„¶å¾Œé»æ“Šã€Œâœ“ å¥—ç”¨ç¯©é¸ã€</div>
            <p>å…±åµæ¸¬åˆ° ${allRawFiles.length} å€‹æ”¯æ´çš„æª”æ¡ˆ</p>
        </td></tr>`;
        
        document.getElementById('fileCountDisplay').textContent = '0';
        document.getElementById('totalFiles').textContent = allRawFiles.length;
        
        smartAnalyzeBtn.disabled = true;
        applyRulesBtn.disabled = true;
        exportBatBtn.disabled = true;
        previewBatBtn.disabled = true;
        
        progressFill.style.width = '0%';
        statusText.textContent = `ğŸ“ åµæ¸¬åˆ° ${allRawFiles.length} å€‹æª”æ¡ˆï¼Œè«‹é¸æ“‡è¦è™•ç†çš„æª”æ¡ˆé¡å‹`;
    });
    </script>
</body>
</html>
